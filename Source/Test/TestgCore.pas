unit TestgCore;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Classes,gCore, System.Rtti,
  Xml.XMLDoc,
  Xml.XMLDom,
  Xml.XMLIntf;

type
  TIDObject3 = class;
  TIDObject2 = class;
  // Test methods for class TgBase

  ///	<summary>
  ///	  This is a example structure which will automaticly limit all
  ///	  assignements to the first 5 characters of the text
  ///	</summary>
  TgString5 = record
  strict private
    FValue: String;
  public
    function GetValue: String;
    procedure SetValue(const AValue: String);
    class operator implicit(AValue: Variant): TgString5; overload;
    class operator Implicit(AValue: TgString5): Variant; overload;
    property Value: String read GetValue write SetValue;
  end;

  ValidatePhone = class(Validation)
  public
    procedure Execute(AObject: TgObject; ARTTIProperty: TRttiProperty); override;
  end;

  ///	<summary>
  ///	  This is a example which should automaticly format any value assigned
  ///	  into a phone number
  ///	</summary>
  [ValidatePhone]
  TPhoneString = record
  strict private
    FValue: String;
  public
    function FormatPhone(AValue : String): String;
    function GetValue: String;
    procedure SetValue(const AValue: String);
    class operator Implicit(AValue: TPhoneString): Variant; overload;
    class operator Implicit(AValue: Variant): TPhoneString; overload;
    property Value: String read GetValue write SetValue;
  end;

  TBase2 = class(TgObject)
  strict private
    FIntegerProperty: Integer;
    FStringProperty: TgString5;
  published
    [DefaultValue(2)]
    property IntegerProperty: Integer read FIntegerProperty write FIntegerProperty;
    [DefaultValue('12345')]
    property StringProperty: TgString5 read FStringProperty write FStringProperty;
  End;

  TBase2List = Class(TgList<TBase2>)
  End;

  TBase3 = Class(TBase2)
  strict private
    FList: TBase2List;
    FName: String;
  published
    property Name: String read FName write FName;
    property List: TBase2List read FList;
  End;

  TBase = class(TgObject)
  strict private
    FBooleanProperty: Boolean;
    FDateProperty: TDate;
    FDateTimeProperty: TDateTime;
    FIntegerProperty: Integer;
    FManuallyConstructedObjectProperty: TBase;
    FObjectProperty: TBase2;
    FPhone: TPhoneString;
    FString5: TgString5;
    FStringProperty: String;
    FUnconstructedObjectProperty: TgBase;
    FUnreadableIntegerProperty: Integer;
    FUnwriteableIntegerProperty: Integer;
    function GetManuallyConstructedObjectProperty: TBase;
  public
    destructor Destroy; override;
  published
    procedure SetUnwriteableIntegerProperty;
    property BooleanProperty: Boolean read FBooleanProperty write FBooleanProperty;
    [Required]
    property DateProperty: TDate read FDateProperty write FDateProperty;
    [Required]
    property DateTimeProperty: TDateTime read FDateTimeProperty write FDateTimeProperty;
    [DefaultValue(5)] [Required]
    property IntegerProperty: Integer read FIntegerProperty write FIntegerProperty;
    property ManuallyConstructedObjectProperty: TBase read GetManuallyConstructedObjectProperty;
    [Required]
    property ObjectProperty: TBase2 read FObjectProperty;
    [DefaultValue('Test')] [NotSerializable] [NotAssignable] [Required]
    property StringProperty: String read FStringProperty write FStringProperty;
    [NotAutoCreate]
    property UnconstructedObjectProperty: TgBase read FUnconstructedObjectProperty write FUnconstructedObjectProperty;
    property UnreadableIntegerProperty: Integer write FUnreadableIntegerProperty;
    property UnwriteableIntegerProperty: Integer read FUnwriteableIntegerProperty;
    [Required]
    property String5: TgString5 read FString5 write FString5;
    property Phone: TPhoneString read FPhone write FPhone;
  end;

  TestTBase = class(TTestCase)
  strict private
    Base: TBase;
  public
    procedure PathEndsWithAnObjectProperty;
    procedure PathExtendsBeyondOrdinalProperty;
    procedure PropertyNotReadable;
    procedure PropertyNotWriteable;
    procedure SetPathEndsWithAnObjectProperty;
    procedure SetPathExtendsBeyondOrdinalProperty;
    procedure SetUndeclaredProperty;
    procedure SetUp; override;
    procedure TearDown; override;
    procedure UndeclaredProperty;
  published
    procedure GetValue;
    procedure SetValue;
    procedure Assign;
    procedure DeserializeXML;
    procedure DeserializeJSON;
    procedure DeserializeCSV;
    procedure PathName;
    procedure SerializeXML;
    procedure SerializeJSON;
    procedure SerializeCSV;
    procedure TestCreate;
    procedure ValidateRequired;
  end;

  TestTgString5 = class(TTestCase)
  published
    procedure TestLength;
  end;

  TestTBase2List = class(TTestCase)
  strict private
    FBase2List: TBase2List;
    procedure Add3;
  public
    procedure CurrentOnEmptyList;
    procedure DeleteFromEmptyList;
    procedure GetItemInvalidIndex;
    procedure SetItemInvalidIndex;
    procedure GetValueInvalidIndex;
    procedure NextPastEOL;
    procedure PreviousBeforeBOL;
    procedure SetValueInvalidIndex;
    procedure SetCurrentIndexTooHigh;
    procedure SetCurrentIndexTooLow;
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure Add;
    procedure Assign;
    procedure BOL;
    procedure EOL;
    procedure CanAdd;
    procedure CanNext;
    procedure CanPrevious;
    procedure Clear;
    procedure Count;
    procedure Current;
    procedure CurrentIndex;
    procedure Delete;
    procedure First;
    procedure GetItem;
    procedure SetItem;
    procedure Last;
    procedure GetValue;
    procedure HasItems;
    procedure ItemClass;
    procedure Next;
    procedure Previous;
    procedure SerializeXML;
    procedure SerializeJSON;
    procedure SerializeCSV;
    procedure DeserializeXML;
    procedure DeserializeJSON;
    procedure DeserializeCSV;
    procedure Filter;
    procedure SetValue;
    procedure Sort;
    procedure TestCreate(BOL: Integer; const Value: string);
  end;

  TIdentityObject = class(TgIDObject)
  strict private
    FName: String;
  published
    [Required]
    property Name: String read FName write FName;
  end;

  TestTIdentityObject = class(TTestCase)
  strict private
    FIdentityObject: TIdentityObject;
  public
    procedure SaveWithoutName;
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure Delete;
    procedure Save;
  end;

  TIdentityObjectList = class(TgIdentityList<TIdentityObject>)
  end;

  TestTIdentityObjectList = class(TTestCase)
  strict private
    FIdentityObjectList: TIdentityObjectList;
    procedure Add3;
  public
    procedure CurrentOnEmptyList;
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure ForInEmpty;
    procedure Add;
    procedure BOL;
    procedure EOL;
    procedure Count;
    procedure Current;
    procedure Delete;
    procedure DeserializeJSON;
    procedure DeserializeXML;
    procedure DeserializeCSV;
    procedure Filter;
    procedure SerializeJSON;
    procedure SerializeXML;
    procedure SerializeCSV;
  end;

  TestTBase3 = class(TTestCase)
  strict private
    Base3: TBase3;
    procedure Add3;
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure SerializeXML;
    procedure SerializeCSV;
    procedure DeserializeXML;
    procedure DeserializeCSV;
    procedure PathName;
  end;

  TIDObject = class(TgIDObject)
  strict private
    FName: String;
    FName2: String;
  published
    property Name: String read FName write FName;
    property Name2: String read FName2 write FName2;
  end;

  TestTIDObject = class(TTestCase)
  strict private
    IDObject: TIDObject;
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure Save;
    procedure SaveChanges;
  end;

  TIDObject3 = class(TgIDObject)
  strict private
    FIDObject2: TIDObject2;
    FName: String;
  published
    property IDObject2: TIDObject2 read FIDObject2;
    property Name: String read FName write FName;
  end;

  TIDObject2 = class(TgIDObject)
  strict private
    FIDObject: TIDObject;
    FIDObjects: TgIdentityList<TIDObject3>;
    FName: String;
  published
    property Name: String read FName write FName;
    property IDObject: TIDObject read FIDObject;
    property IDObjects: TgIdentityList<TIDObject3> read FIDObjects;
  end;

  TestTIDObject2 = class(TTestCase)
  strict private
    FIDObject: TIDObject;
    FIDObject2: TIDObject2;
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  public
    procedure Add3Items;
  published
    procedure ExtendedWhere;
    procedure Save;
    procedure SaveItem;
  end;

(*
  TestTgNodeCSV = class(TTestCase)
  protected
    FNode: TgNodeCSV;
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure ColumnName;
    procedure NestedColumnName;
  end;
*)
  TestTSerializeCSV = class(TTestCase)
  public
    type
      TgName = class(TgBase)
      private
        FName: String;
      published
        property Name: String read FName write FName;
      end;
      TgTest = class(TgBase)
      private
        FName: String;
        FPrice: Currency;
        FNames: TgList<TgName>;
      public
        constructor Create(AOwner: TgBase = nil); override;
      published
        property Name: String read FName write FName;
        property Price: Currency read FPrice write FPrice;
        property Names: TgList<TgName> read FNames write FNames;
      end;
  protected
    FSerializer: TgSerializerCSV;
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure Serialize;
    procedure Deserialize;
    procedure DeserializeArr;
    procedure SerializeList;
    procedure DeserializeList;
    procedure SerializeCRLF;
    procedure DeserializeCRLF;
  end;

  TestHTMLParser = class(TTestCase)
  public
    type

      TCustomer = class(TgObject)
      private
        FFirstName: String;
        FLastName: String;
        FWebAddress: String;
        FGoodCustomer: Boolean;
        FOtherCustomer: TCustomer;
        FWebContent: TgHTMLString;
        FNotes: String;
      published
        property FirstName: String read FFirstName write FFirstName;
        property LastName: String read FLastName write FLastName;
        property WebAddress: String read FWebAddress write FWebAddress;
        property Notes: String read FNotes write FNotes;
        property WebContent: TgHTMLString read FWebContent write FWebContent;
        property GoodCustomer: Boolean read FGoodCustomer write FGoodCustomer;
        property OtherCustomer: TCustomer read FOtherCustomer write FOtherCustomer;
      end;

      TCustomers = TgList<TCustomer>;

      TModel = class(TgModel)
      private
        FCustomers: TCustomers;
      published
        property Customers: TCustomers read FCustomers;
      end;
  published
    procedure Replace;
    procedure Convert1;
    procedure ListTag;
    procedure IncludeTag;
    procedure AssignTag;
    procedure WithTag;
    procedure ifTag;
    procedure HTMLField;
  end;

  [PersistenceManagerClassName('gCore.TgPersistenceManagerIBX')]
  TFirebirdObject = class(TgIDObject)
  strict private
    FName: TString50;
  published
    property Name: TString50 read FName write FName;
  end;

  TestTFirebirdObject = class(TTestCase)
  strict private
    FFirebirdObject: TFirebirdObject;
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure Save;
  end;

  TestEvalHTML = class(TTestCase)
    type
      TTest = class(TgBase)
      strict private
        FHTMLString: TgHTMLString;
        FNonHTMLString: String;
      Published
        property HTMLString: TgHTMLString read FHTMLString write FHTMLString;
        property NonHTMLString: String read FNonHTMLString write FNonHTMLString;
      end;
  strict private
    TestObject: TTest;
  protected
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure Eval;
  end;

implementation

Uses
  SysUtils,
  Character,
  Math
  ;

procedure TestTBase.GetValue;
begin
  // Given a Pathname, return the property value
  CheckEquals('Test', Base['StringProperty'], 'Non-Object Property');
  CheckEquals('Test', Base['ManuallyConstructedObjectProperty.StringProperty'], 'Object Property');
  // If the property doesn't exist, raise an exception
  CheckException(UndeclaredProperty, TgBase.EgValue);
  // If the path extends beyond an ordinal property, raise an exception
  CheckException(PathExtendsBeyondOrdinalProperty, TgBase.EgValue);
  // If the path ends with an object property, raise an exception
  CheckException(PathEndsWithAnObjectProperty, TgBase.EgValue);
  // If the property is not readable, raise an exception
  CheckException(PropertyNotReadable, TgBase.EgValue);
  // Can we get an Active Value?
  Base.String5 := '123456789';
  CheckEquals('12345', Base['String5'], 'Active Value');
  Base.Phone := '5555555555';
  CheckEquals('(555) 555-5555', Base['Phone'], 'Phone');
  Base.BooleanProperty := True;
  CheckEquals(True, Base['BooleanProperty']);
  CheckEquals('True', Base['BooleanProperty']);
  Base.BooleanProperty := False;
  CheckEquals(False, Base['BooleanProperty']);
  CheckEquals('False', Base['BooleanProperty']);
  Base.DateProperty := StrToDate('1/1/12');
  CheckEquals(StrToDate('1/1/12'), Base['DateProperty'], 'Date as TDate');
  CheckEquals(FloatToStr(StrToDate('1/1/12')), Base['DateProperty'], 'Date as String');
  Base.DateTimeProperty := StrToDateTime('1/1/12 12:34 am');
  CheckEquals(StrToDateTime('1/1/12 12:34 am'), Base['DateTimeProperty'], 'DateTime as TDateTime');
  CheckEquals(FloatToStr(StrToDateTime('1/1/12 12:34 am')), Base['DateTimeProperty'], 'DateTime as String');
end;

procedure TestTBase.PathEndsWithAnObjectProperty;
begin
  Base['ObjectProperty'];
end;

procedure TestTBase.PathExtendsBeyondOrdinalProperty;
begin
  Base['IntegerProperty.ThisShouldNotBeHere'];
end;

procedure TestTBase.PropertyNotReadable;
begin
  Base['UnreadableIntegerProperty'];
end;

procedure TestTBase.PropertyNotWriteable;
begin
  Base['UnwriteableIntegerProperty'] := 5;
end;

procedure TestTBase.SetPathEndsWithAnObjectProperty;
begin
  Base['ObjectProperty'] := 'Test';
end;

procedure TestTBase.SetPathExtendsBeyondOrdinalProperty;
begin
  Base['IntegerProperty.ThisShouldNotBeHere'] := 'Test';
end;

procedure TestTBase.SetUndeclaredProperty;
begin
  Base['ThisPropertyDoesNotExist'] := 'Test';
end;

procedure TestTBase.SetUp;
begin
  Base := TBase.Create;
end;

procedure TestTBase.SetValue;
begin
  // Given a Pathname, set the property value
  Base['StringProperty'] := 'Test2';
  CheckEquals('Test2', Base.StringProperty, 'Non-Object Property');
  Base['ManuallyConstructedObjectProperty.StringProperty'] := 'Test2';
  CheckEquals('Test2', Base.ManuallyConstructedObjectProperty.StringProperty, 'Object Property');
  // If the property doesn't exist, raise an exception
  CheckException(SetUndeclaredProperty, TgBase.EgValue);
  // If the path extends beyond a non-object property, raise an exception
  CheckException(SetPathExtendsBeyondOrdinalProperty, TgBase.EgValue);
  // If the path ends with an object property, raise an exception
  CheckException(SetPathEndsWithAnObjectProperty, TgBase.EgValue);
  // If the property is not writeable, raise an exception
  CheckException(PropertyNotWriteable, TgBase.EgValue);
  // Call a method
  Base['SetUnwriteableIntegerProperty'] := '';
  CheckEquals(10, Base.UnwriteableIntegerProperty);
  Base['ManuallyConstructedObjectProperty.SetUnwriteableIntegerProperty'] := '';
  CheckEquals(10, Base.ManuallyConstructedObjectProperty.UnwriteableIntegerProperty);
  Base['String5'] := '123456789';
  CheckEquals('12345', Base.String5);
  Base['BooleanProperty'] := True;
  CheckEquals(True, Base.BooleanProperty);
  Base['BooleanProperty'] := False;
  CheckEquals(False, Base.BooleanProperty);
  Base['BooleanProperty'] := 'True';
  CheckEquals(True, Base.BooleanProperty);
  Base['BooleanProperty'] := 'False';
  CheckEquals(False, Base.BooleanProperty);
  Base['DateProperty'] := StrToDate('1/1/12');
  CheckEquals(StrToDate('1/1/12'), Base.DateProperty, 'Date as TDate');
  Base['DateProperty'] := '1/1/12';
  CheckEquals(StrToDate('1/1/12'), Base.DateProperty, 'Date as String');
  Base['DateTimeProperty'] := StrToDateTime('1/1/12 12:34 am');
  CheckEquals(StrToDateTime('1/1/12 12:34 am'), Base.DateTimeProperty, 'DateTime as TDateTime');
  Base['DateTimeProperty'] := '1/1/12 12:34 am';
  CheckEquals(StrToDateTime('1/1/12 12:34 am'), Base.DateTimeProperty, 'DateTime as String');
end;

procedure TestTBase.TearDown;
begin
  FreeAndNil(Base);
end;

procedure TestTBase.Assign;
var
  Target: TBase;
begin
  Target := TBase.Create(Base);
  try
    Base.IntegerProperty := 6;
    Base.StringProperty := 'Hello';
    Base.Phone := '5555555555';
    Target.Assign(Base);
    CheckEquals(6, Target.IntegerProperty);
    CheckNull(Target.Inspect(G.PropertyByName(Target, 'ManuallyConstructedObjectProperty')));
    CheckEquals('Test', Target.StringProperty);
    CheckEquals('(555) 555-5555', Target.Phone);
  finally
    Target.Free;
  end;
end;

procedure TestTBase.DeserializeXML;
var
  XMLString: string;
begin
  XMLString :=
    '<xml>'#13#10 + //0
    '  <Base classname="TestgCore.TBase">'#13#10 + //1
    '    <BooleanProperty>True</BooleanProperty>'#13#10 + //2
    '    <DateProperty>1/1/2012</DateProperty>'#13#10 + //3
    '    <DateTimeProperty>1/1/2012 00:34:00</DateTimeProperty>'#13#10 + //4
    '    <IntegerProperty>5</IntegerProperty>'#13#10 + //5
    '    <ManuallyConstructedObjectProperty classname="TestgCore.TBase">'#13#10 + //6
    '      <BooleanProperty>False</BooleanProperty>'#13#10 + //7
    '      <DateProperty>12/30/1899</DateProperty>'#13#10 + //8
    '      <DateTimeProperty>12/30/1899 00:00:00</DateTimeProperty>'#13#10 + //9
    '      <IntegerProperty>6</IntegerProperty>'#13#10 + //10
    '      <ObjectProperty classname="TestgCore.TBase2">'#13#10 + //11
    '        <IntegerProperty>2</IntegerProperty>'#13#10 + //12
    '        <StringProperty>12345</StringProperty>'#13#10 + //13
    '      </ObjectProperty>'#13#10 + //14
    '      <String5>98765</String5>'#13#10 + //15
    '      <Phone>(444) 444-4444</Phone>'#13#10 + //16
    '    </ManuallyConstructedObjectProperty>'#13#10 + //17
    '    <ObjectProperty classname="TestgCore.TBase2">'#13#10 + //18
    '      <IntegerProperty>2</IntegerProperty>'#13#10 + //19
    '      <StringProperty>12345</StringProperty>'#13#10 + //20
    '    </ObjectProperty>'#13#10 + //21
    '    <String5>12345</String5>'#13#10 + //22
    '    <Phone>(555) 555-5555</Phone>'#13#10 + //23
    '  </Base>'#13#10 + //24
    '</xml>'#13#10; //25
  Base.Deserialize(TgSerializerXML, XMLString);
  CheckEquals('12345', Base.String5);
  CheckEquals('(555) 555-5555', Base.Phone);
  CheckEquals(6, Base.ManuallyConstructedObjectProperty.IntegerProperty);
  CheckEquals('98765', Base.ManuallyConstructedObjectProperty.String5);
  CheckEquals('(444) 444-4444', Base.ManuallyConstructedObjectProperty.Phone);
  CheckEquals(True, Base.BooleanProperty);
  CheckEquals(StrToDate('1/1/12'), Base.DateProperty);
  CheckEquals(StrToDateTime('1/1/12 12:34 am'), Base.DateTimeProperty);
end;

procedure TestTBase.DeserializeCSV;
var
  CSVString: string;
begin
  CSVString :=
    'BooleanProperty,DateProperty,DateTimeProperty,IntegerProperty,StringProperty,String5,Phone,ManuallyConstructedObjectProperty.BooleanProperty,ManuallyConstructedObjectProperty.DateProperty,ManuallyConstructedObjectProperty.DateTimeProperty,'
       +'ManuallyConstructedObjectProperty.IntegerProperty,ManuallyConstructedObjectProperty.ObjectProperty.IntegerProperty,ManuallyConstructedObjectProperty.ObjectProperty.StringProperty,ManuallyConstructedObjectProperty.String5,'
       +'ManuallyConstructedObjectProperty.Phone,ObjectProperty.IntegerProperty,ObjectProperty.StringProperty'#$D#$A
    +'True,1/1/2012,"1/1/2012 00:34:00",5,,,,False,12/30/1899,"12/30/1899 00:00:00",6,2,12345,98765,"(444) 444-4444"'#$D#$A
    +',,,,,,,,,,,,,,,2,12345'#$D#$A
    +',,,,,12345,"(555) 555-5555"'#$D#$A;
  Base.Deserialize(TgSerializerCSV, CSVString);
  CheckEquals('12345', Base.String5);
  CheckEquals('(555) 555-5555', Base.Phone);
  CheckEquals(6, Base.ManuallyConstructedObjectProperty.IntegerProperty);
  CheckEquals('98765', Base.ManuallyConstructedObjectProperty.String5);
  CheckEquals('(444) 444-4444', Base.ManuallyConstructedObjectProperty.Phone);
  CheckEquals(True, Base.BooleanProperty);
  CheckEquals(StrToDate('1/1/12'), Base.DateProperty);
  CheckEquals(StrToDateTime('1/1/12 12:34 am'), Base.DateTimeProperty);

end;

procedure TestTBase.DeserializeJSON;
var
  JSONString: string;
begin
  JSONString :=
    '{"ClassName":"TestgCore.TBase","BooleanProperty":"True","DateProperty":"1/'+
    '1/2012","DateTimeProperty":"1/1/2012 00:34:00","IntegerProperty":"5","Manu'+
    'allyConstructedObjectProperty":{"ClassName":"TestgCore.TBase","BooleanProp'+
    'erty":"False","DateProperty":"12/30/1899","DateTimeProperty":"12/30/1899 0'+
    '0:00:00","IntegerProperty":"6","ObjectProperty":{"ClassName":"TestgCore.TB'+
    'ase2","IntegerProperty":"2","StringProperty":"12345"},"String5":"98765","P'+
    'hone":"(444) 444-4444"},"ObjectProperty":{"ClassName":"TestgCore.TBase2","'+
    'IntegerProperty":"2","StringProperty":"12345"},"String5":"12345","Phone":"'+
    '(555) 555-5555"}';
  Base.Deserialize(TgSerializerJSON, JSONString);
  CheckEquals('12345', Base.String5);
  CheckEquals('(555) 555-5555', Base.Phone);
  CheckEquals(6, Base.ManuallyConstructedObjectProperty.IntegerProperty);
  CheckEquals('98765', Base.ManuallyConstructedObjectProperty.String5);
  CheckEquals('(444) 444-4444', Base.ManuallyConstructedObjectProperty.Phone);
  CheckEquals(True, Base.BooleanProperty);
  CheckEquals(StrToDate('1/1/12'), Base.DateProperty);
  CheckEquals(StrToDateTime('1/1/12 12:34 am'), Base.DateTimeProperty);
end;

procedure TestTBase.PathName;
begin
  CheckEquals('', Base.PathName);
  CheckEquals('ManuallyConstructedObjectProperty', Base.ManuallyConstructedObjectProperty.PathName);
end;

procedure TestTBase.SerializeXML;
var
  XMLString: string;
begin
  Base.String5 := '123456789';
  Base.Phone := '5555555555';
  Base.ManuallyConstructedObjectProperty.IntegerProperty := 6;
  Base.ManuallyConstructedObjectProperty.String5 := '987654321';
  Base.ManuallyConstructedObjectProperty.Phone := '4444444444';
  Base.BooleanProperty := True;
  Base.DateProperty := StrToDate('1/1/12');
  Base.DateTimeProperty := StrToDateTime('1/1/12 12:34 am');
  XMLString :=
    '<xml>'#13#10 + //0
    '  <Base classname="TestgCore.TBase">'#13#10 + //1
    '    <BooleanProperty>True</BooleanProperty>'#13#10 + //2
    '    <DateProperty>1/1/2012</DateProperty>'#13#10 + //3
    '    <DateTimeProperty>1/1/2012 00:34:00</DateTimeProperty>'#13#10 + //4
    '    <IntegerProperty>5</IntegerProperty>'#13#10 + //5
    '    <ManuallyConstructedObjectProperty classname="TestgCore.TBase">'#13#10 + //6
    '      <BooleanProperty>False</BooleanProperty>'#13#10 + //7
    '      <DateProperty>12/30/1899</DateProperty>'#13#10 + //8
    '      <DateTimeProperty>12/30/1899 00:00:00</DateTimeProperty>'#13#10 + //9
    '      <IntegerProperty>6</IntegerProperty>'#13#10 + //10
    '      <ObjectProperty classname="TestgCore.TBase2">'#13#10 + //11
    '        <IntegerProperty>2</IntegerProperty>'#13#10 + //12
    '        <StringProperty>12345</StringProperty>'#13#10 + //13
    '      </ObjectProperty>'#13#10 + //14
    '      <String5>98765</String5>'#13#10 + //15
    '      <Phone>(444) 444-4444</Phone>'#13#10 + //16
    '    </ManuallyConstructedObjectProperty>'#13#10 + //17
    '    <ObjectProperty classname="TestgCore.TBase2">'#13#10 + //18
    '      <IntegerProperty>2</IntegerProperty>'#13#10 + //19
    '      <StringProperty>12345</StringProperty>'#13#10 + //20
    '    </ObjectProperty>'#13#10 + //21
    '    <String5>12345</String5>'#13#10 + //22
    '    <Phone>(555) 555-5555</Phone>'#13#10 + //23
    '  </Base>'#13#10 + //24
    '</xml>'#13#10; //25
  CheckEquals(XMLString, Base.Serialize(TgSerializerXML));
end;

procedure TestTBase.SerializeCSV;
var
  CSVString1, CSVString: string;
begin
  Base.String5 := '123456789';
  Base.Phone := '5555555555';
  Base.ManuallyConstructedObjectProperty.IntegerProperty := 6;
  Base.ManuallyConstructedObjectProperty.String5 := '987654321';
  Base.ManuallyConstructedObjectProperty.Phone := '4444444444';
  Base.BooleanProperty := True;
  Base.DateProperty := StrToDate('1/1/12');
  Base.DateTimeProperty := StrToDateTime('1/1/12 12:34 am');
  CSVString1 := Base.Serialize(TgSerializerCSV);
  CSVString :=
    'BooleanProperty,DateProperty,DateTimeProperty,IntegerProperty,StringProperty,String5,Phone,ManuallyConstructedObjectProperty.BooleanProperty,ManuallyConstructedObjectProperty.DateProperty,ManuallyConstructedObjectProperty.DateTimeProperty,'
       +'ManuallyConstructedObjectProperty.IntegerProperty,ManuallyConstructedObjectProperty.ObjectProperty.IntegerProperty,ManuallyConstructedObjectProperty.ObjectProperty.StringProperty,ManuallyConstructedObjectProperty.String5,'
       +'ManuallyConstructedObjectProperty.Phone,ObjectProperty.IntegerProperty,ObjectProperty.StringProperty'#$D#$A
    +'True,1/1/2012,"1/1/2012 00:34:00",5,,,,False,12/30/1899,"12/30/1899 00:00:00",6,2,12345,98765,"(444) 444-4444"'#$D#$A
    +',,,,,,,,,,,,,,,2,12345'#$D#$A
    +',,,,,12345,"(555) 555-5555"'#$D#$A;
  CheckEquals(CSVString,CSVString1);
end;

procedure TestTBase.SerializeJSON;
var
  JSONString: string;
begin
  Base.String5 := '123456789';
  Base.Phone := '5555555555';
  Base.ManuallyConstructedObjectProperty.IntegerProperty := 6;
  Base.ManuallyConstructedObjectProperty.String5 := '987654321';
  Base.ManuallyConstructedObjectProperty.Phone := '4444444444';
  Base.BooleanProperty := True;
  Base.DateProperty := StrToDate('1/1/12');
  Base.DateTimeProperty := StrToDateTime('1/1/12 12:34 am');
  JSONString :=
    '{"ClassName":"TestgCore.TBase","BooleanProperty":"True","DateProperty":"1/'+
    '1/2012","DateTimeProperty":"1/1/2012 00:34:00","IntegerProperty":"5","Manu'+
    'allyConstructedObjectProperty":{"ClassName":"TestgCore.TBase","BooleanProp'+
    'erty":"False","DateProperty":"12/30/1899","DateTimeProperty":"12/30/1899 0'+
    '0:00:00","IntegerProperty":"6","ObjectProperty":{"ClassName":"TestgCore.TB'+
    'ase2","IntegerProperty":"2","StringProperty":"12345"},"String5":"98765","P'+
    'hone":"(444) 444-4444"},"ObjectProperty":{"ClassName":"TestgCore.TBase2","'+
    'IntegerProperty":"2","StringProperty":"12345"},"String5":"12345","Phone":"'+
    '(555) 555-5555"}';
  CheckEquals(JSONString, Base.Serialize(TgSerializerJSON));
end;

procedure TestTBase.TestCreate;
var
  Base1: TBase;
  Base2: TBase2;
begin
  CheckNull(Base.Owner, 'When a constructor is called without a parameter, its owner should be nil.');
  CheckNotNull(Base.ObjectProperty, 'Object properties should be constructed automatically if the Exclude([AutoCreate]) attribute is not set.');
  CheckNull(Base.UnconstructedObjectProperty, 'Object properties with the Exlude([AutoCreate]) attribute should not be nil.');
  Check(Base=Base.ObjectProperty.Owner, 'The owner of an automatically constructed object property shoud be set to the object that created it.');
  CheckEquals(5, Base.IntegerProperty, 'Default integer values should be set for properties with a DefaultValue attribute.');
  CheckEquals('Test', Base.StringProperty, 'Default string values should be set for properties with a DefaultValue attribute.');
  Base2 := TBase2.Create;
  try
    Base1 := TBase.Create(Base2);
    try
      Check(Base1.ObjectProperty = Base2, 'Object properties should take the value of an existing owner object if one exists.');
    finally
      Base1.Free;
    end;
  finally
    Base2.Free;
  end;
end;

procedure TestTBase.UndeclaredProperty;
begin
  Base['ThisPropertyDoesNotExist'];
end;

procedure TestTBase.ValidateRequired;
begin
  Base.DateProperty := Date;
  Base.DateTimeProperty := Now;
  Base.IntegerProperty := 1;
  Base.StringProperty := 'Hello';
  Base.String5 := '12345';
  Base.Phone := '1234567890';
  CheckTrue(Base.IsValid);
  Base.DateProperty := 0;
  CheckFalse(Base.IsValid, 'Base.IsValid (DateProperty)');
  Check(Base.ValidationErrors['DateProperty'] > '', 'Base.ValidationErrors[''DateProperty''] > ''''');
  Base.DateProperty := Date;
  Base.DateTimeProperty := 0;
  CheckFalse(Base.IsValid, 'Base.IsValid (DateTimeProperty)');
  Check(Base.ValidationErrors['DateTimeProperty'] > '', 'Base.ValidationErrors[''DateTimeProperty''] > ''''');
  Base.DateTimeProperty := Now;
  Base.IntegerProperty := 0;
  CheckFalse(Base.IsValid, 'Base.IsValid (DateProperty)');
  Check(Base.ValidationErrors['IntegerProperty'] > '', 'Base.ValidationErrors[''Integer''] > ''''');
  Base.IntegerProperty := 1;
  Base.StringProperty := '';
  CheckFalse(Base.IsValid, 'Base.IsValid (StringProperty)');
  Check(Base.ValidationErrors['StringProperty'] > '', 'Base.ValidationErrors[''StringProperty''] > ''''');
  Base.StringProperty := 'Hello';
  Base.String5 := '';
  CheckFalse(Base.IsValid, 'Base.IsValid (String5)');
  Check(Base.ValidationErrors['String5'] > '', 'Base.ValidationErrors[''String5''] > ''''');
end;

destructor TBase.Destroy;
begin
  FreeAndNil(FManuallyConstructedObjectProperty);
  inherited Destroy;
end;

function TBase.GetManuallyConstructedObjectProperty: TBase;
begin
  if Not IsInspecting And Not Assigned(FManuallyConstructedObjectProperty) then
    FManuallyConstructedObjectProperty := TBase.Create(Self);
  Result := FManuallyConstructedObjectProperty;
end;

procedure TBase.SetUnwriteableIntegerProperty;
begin
  FUnwriteableIntegerProperty := 10;
end;

function TgString5.GetValue: String;
begin
  Result := FValue;
end;

procedure TgString5.SetValue(const AValue: String);
begin
  FValue := Copy(AValue, 1, 5);
end;

class operator TgString5.implicit(AValue: Variant): TgString5;
begin
  Result.Value := AValue;
end;

class operator TgString5.Implicit(AValue: TgString5): Variant;
begin
  Result := AValue.Value;
end;

procedure TestTgString5.TestLength;
var
  String5: TgString5;
begin
  String5 := '123456789';
  CheckEquals('12345', String5);
end;

function TPhoneString.FormatPhone(AValue : String): String;
Var
  CurrentCharacter: Char;
Begin
  Result := '';
  for CurrentCharacter in AValue do
  Begin
    if IsNumber(CurrentCharacter) then
      Result := Result + CurrentCharacter;
  End;
  Case Length(Result) Of
    7 :
    Begin
      Insert('(   ) ', Result, 1);
      Insert('-', Result, 10);
    End;
    10 :
    Begin
      Insert('(', Result, 1);
      Insert(') ', Result, 5);
      Insert('-', Result, 10);
    End;
    Else
      Result := AValue;
  End;
End;

function TPhoneString.GetValue: String;
begin
  Result := FValue;
end;

procedure TPhoneString.SetValue(const AValue: String);
begin
  FValue := FormatPhone(AValue);
end;

class operator TPhoneString.Implicit(AValue: TPhoneString): Variant;
begin
  Result := AValue.Value;
end;

class operator TPhoneString.Implicit(AValue: Variant): TPhoneString;
begin
  Result.Value := AValue;
end;

procedure TestTBase2List.Add;
begin
  Add3;
  CheckEquals(3, FBase2List.Count, 'There should be 3 items in the list.');
  CheckEquals(3, FBase2List.Current.IntegerProperty, 'The last item added should be the current one.');
  CheckEquals(2, FBase2List.CurrentIndex, 'The CurrentIndex value should be one less than the count.');
  CheckEquals(TBase2, FBase2List.Current.ClassType, 'Constructs the new list item from ItemClass, which in this case, is the generic class.');
  FBase2List.ItemClass := TBase3;
  FBase2List.Add;
  CheckEquals(TBase3, FBase2List.Current.ClassType, 'Constructs the new list item from the new ItemClass.');
end;

procedure TestTBase2List.Add3;
var
  Counter: Integer;
begin
  for Counter := 1 to 3 do
  Begin
    FBase2List.Add;
    FBase2List.Current.IntegerProperty := Counter;
  End;
end;

procedure TestTBase2List.Assign;
var
  NewBase2List: TBase2List;
begin
  Add3;
  NewBase2List := TBase2List.Create;
  try
    NewBase2List.Assign(FBase2List);
    CheckEquals(3, NewBase2List.Count, 'Should have copied 3 items.');
    CheckEquals(3, NewBase2List[2].IntegerProperty, 'Make sure the value got copied.');
  finally
    NewBase2List.Free;
  end;
end;

procedure TestTBase2List.BOL;
begin
  CheckTrue(FBase2List.BOL, 'When there are no items, BOL should be true.');
  FBase2List.Add;
  CheckFalse(FBase2List.BOL, 'When there is one item and it''s the current one, BOL should be false.');
  FBase2List.Previous;
  CheckTrue(FBase2List.BOL, 'If you try to move before the first item, BOL should be true');
  FBase2List.Last;
  CheckFalse(FBase2List.BOL, 'This should make the only item current and set EOL, but not BOL.');
  FBase2List.First;
  CheckTrue(FBase2List.BOL, 'Calling First shoule make BOL true.');
end;

procedure TestTBase2List.EOL;
begin
  CheckTrue(FBase2List.EOL, 'When there are no items, EOL should be true.');
  FBase2List.Add;
  CheckFalse(FBase2List.EOL, 'When there is one item and it''s the current one, EOL should be false.');
  FBase2List.Next;
  CheckTrue(FBase2List.EOL, 'If you try to move after the only item, EOL should be true');
  FBase2List.First;
  CheckFalse(FBase2List.EOL, 'This should make the only item current, but not set EOL.');
  FBase2List.Last;
  CheckTrue(FBase2List.EOL, 'Calling Last shoule make EOL true.');
end;

procedure TestTBase2List.CanAdd;
begin
  CheckTrue(FBase2List.CanAdd);
end;

procedure TestTBase2List.CanNext;
begin
  CheckFalse(FBase2List.CanNext, 'Always false for an empty list.');
  FBase2List.Add;
  CheckFalse(FBase2List.CanNext, 'Always false for the last item in the list.');
  FBase2List.Add;
  FBase2List.Previous;
  CheckTrue(FBase2List.CanNext, 'Always true if list not empty and not on the last item.');
end;

procedure TestTBase2List.CanPrevious;
begin
  CheckFalse(FBase2List.CanPrevious, 'Always false for an empty list.');
  FBase2List.Add;
  CheckFalse(FBase2List.CanPrevious, 'Always false for the first item in the list.');
  FBase2List.Add;
  CheckTrue(FBase2List.CanPrevious, 'Always true if list not empty and not on the first item.');
end;

procedure TestTBase2List.Clear;
begin
  Add3;
  FBase2List.Clear;
  CheckEquals(0, FBase2List.Count);
end;

procedure TestTBase2List.Count;
begin
  CheckEquals(0, FBase2List.Count, 'When a list is created it has no items');
  Add3;
  FBase2List.Delete;
  CheckEquals(2, FBase2List.Count, 'The count equals the number of items added minus the number deleted.');
end;

procedure TestTBase2List.Current;
begin
  CheckException(CurrentOnEmptyList,TgList.EgList, 'Calling Current on an empty list should cause an exception.');
  Add3;
  FBase2List.CurrentIndex := 1;
  CheckEquals(2, FBase2List.Current.IntegerProperty, 'If there are items in the list, Current returns the item at CurrentIndex (zero based).');
end;

procedure TestTBase2List.CurrentIndex;
begin
  CheckEquals(-1, FBase2List.CurrentIndex, 'CurrentIndex should be -1 on an empty list.');
  Add3;
  while Not FBase2List.BOL do
  Begin
    Check(InRange(FBase2List.CurrentIndex, 0, FBase2List.Count - 1), Format('%d is not in range 0..%d', [FBase2List.CurrentIndex, FBase2List.Count - 1]));
    FBase2List.Previous;
  End;
  FBase2List.Last;
  FBase2List.Delete;
  CheckEquals(1, FBase2List.CurrentIndex, 'When Current is Last, and it gets deleted, CurrentIndex matched the new Last');
  FBase2List.CurrentIndex := 0;
  CheckEquals(0, FBase2List.CurrentIndex, 'Setting CurrentIndex to a valid value should allow you to get that same value.');
  CheckException(SetCurrentIndexTooLow, TgList.EgList, 'CurrentIndex must be greater than or equal to 0.');
  CheckException(SetCurrentIndexTooHigh, TgList.EgList, 'CurrentIndex must be less than or equal to Count - 1.');
end;

procedure TestTBase2List.CurrentOnEmptyList;
begin
  FBase2List.Clear;
  FBase2List.Current;
end;

procedure TestTBase2List.Delete;
begin
  CheckException(DeleteFromEmptyList, TgList.EgList, 'The Delete method may not be called from an empty list.');
  Add3;
  FBase2List.CurrentIndex := 1;
  FBase2List.Delete;
  CheckEquals(2, FBase2List.Count, 'Deleting one of the 3 list items should yield a count of 2.');
  CheckEquals(3, FBase2List.Current.IntegerProperty, 'The 3rd item should have taken the place of the 2nd');
end;

procedure TestTBase2List.DeleteFromEmptyList;
begin
  FBase2List.Clear;
  FBase2List.Delete;
end;

procedure TestTBase2List.First;
begin
  Add3;
  FBase2List.First;
  CheckTrue(FBase2List.BOL, 'First should set BOL');
  CheckEquals(0, FBase2List.CurrentIndex, 'CurrentIndex should be at 0.');
end;

procedure TestTBase2List.GetItem;
begin
  Add3;
  CheckEquals(2, FBase2List.Items[1].IntegerProperty, 'Get the 2nd item in the array');
  CheckException(GetItemInvalidIndex, TgList.EgList, 'Invalid Index');
end;

procedure TestTBase2List.SetItem;
begin
  Add3;
  FBase2List.Items[1].IntegerProperty := 22;
  CheckEquals(22, FBase2List.Items[1].IntegerProperty, 'Get the 2nd item in the array');
  CheckException(SetItemInvalidIndex, TgList.EgList, 'Invalid Index');
end;

procedure TestTBase2List.GetItemInvalidIndex;
begin
  FBase2List.Items[23].IntegerProperty := FBase2List.Items[23].IntegerProperty + 1;
end;

procedure TestTBase2List.SetItemInvalidIndex;
begin
  FBase2List.Items[23].IntegerProperty := 22;
end;

procedure TestTBase2List.Last;
begin
  Add3;
  FBase2List.First;
  FBase2List.Last;
  CheckTrue(FBase2List.EOL, 'Last should set EOL');
  CheckEquals(2, FBase2List.CurrentIndex, 'CurrentIndex should be at 2.');
end;

procedure TestTBase2List.GetValue;
begin
  Add3;
  CheckEquals(3, FBase2List.Values['Current.IntegerProperty'], 'Testing the inherited GetValue');
  CheckEquals(2, FBase2List.Values['[1].IntegerProperty'], 'Testing the overridden GetValues that looks for an index value');
  CheckException(GetValueInvalidIndex, TgBase.EgValue, 'Invalid Index');
end;

procedure TestTBase2List.SetValue;
begin
  FBase2List.Add;
  FBase2List.Values['Current.IntegerProperty'] := 1;
  CheckEquals(1, FBase2List.Current.IntegerProperty, 'Testing the inherited SetValue');
  FBase2List.Values['[0].IntegerProperty'] := 2;
  CheckEquals(2, FBase2List[0].IntegerProperty, 'Testing the overriden SetValue looking for an index value.');
  CheckException(SetValueInvalidIndex, TgBase.EgValue, 'Invalid Index');
end;

procedure TestTBase2List.GetValueInvalidIndex;
begin
  FBase2List.Values['[xyz].IntegerProperty'];
end;

procedure TestTBase2List.HasItems;
begin
  CheckFalse(FBase2List.HasItems, 'Should return False on an empty list.');
  FBase2List.Add;
  CheckTrue(FBase2List.HasItems, 'Should return True on a non-empty list.');
end;

procedure TestTBase2List.ItemClass;
begin
  Check(FBase2List.ItemClass = TBase2, 'The default ItemClass should be the generic type.');
  FBase2List.ItemClass := TBase3;
  CheckEquals(TBase3, FBase2List.ItemClass, 'Should return the ItemClass that was set.');
end;

procedure TestTBase2List.Next;
begin
  CheckException(NextPastEOL, TgList.EgList, 'Exception calling on Empty List');
  Add3;
  FBase2List.Last;
  FBase2List.Previous;
  FBase2List.Next;
  CheckEquals(2, FBase2List.CurrentIndex, 'Should be CurrentIndex2');
  FBase2List.Next;
  CheckTrue(FBase2List.EOL);
  CheckException(NextPastEOL, TgList.EgList, 'Exception calling on EOL.');
end;

procedure TestTBase2List.Previous;
begin
  CheckException(PreviousBeforeBOL, TgList.EgList, 'Exception calling on Empty List');
  Add3;
  FBase2List.First;
  FBase2List.Next;
  FBase2List.Previous;
  CheckEquals(0, FBase2List.CurrentIndex, 'CurrentIndex should be 0');
  FBase2List.Previous;
  CheckTrue(FBase2List.BOL);
  CheckException(PreviousBeforeBOL, TgList.EgList, 'Exception calling on EOL.');
end;

procedure TestTBase2List.NextPastEOL;
begin
  FBase2List.Next;
end;

procedure TestTBase2List.PreviousBeforeBOL;
begin
  FBase2List.Previous;
end;

procedure TestTBase2List.SerializeXML;
var
  XMLString: string;
begin
  Add3;
  XMLString :=
    '<xml>'#13#10 + //0
    '  <Base2List classname="TestgCore.TBase2List">'#13#10 + //1
    '    <List>'#13#10 + //2
    '      <Base2 classname="TestgCore.TBase2">'#13#10 + //3
    '        <IntegerProperty>1</IntegerProperty>'#13#10 + //4
    '        <StringProperty>12345</StringProperty>'#13#10 + //5
    '      </Base2>'#13#10 + //6
    '      <Base2 classname="TestgCore.TBase2">'#13#10 + //7
    '        <IntegerProperty>2</IntegerProperty>'#13#10 + //8
    '        <StringProperty>12345</StringProperty>'#13#10 + //9
    '      </Base2>'#13#10 + //10
    '      <Base2 classname="TestgCore.TBase2">'#13#10 + //11
    '        <IntegerProperty>3</IntegerProperty>'#13#10 + //12
    '        <StringProperty>12345</StringProperty>'#13#10 + //13
    '      </Base2>'#13#10 + //14
    '    </List>'#13#10 + //15
    '  </Base2List>'#13#10 + //16
    '</xml>'#13#10; //17
  CheckEquals(XMLString, FBase2List.Serialize(TgSerializerXML));
end;

procedure TestTBase2List.SerializeCSV;
var
  CSVString: string;
begin
  Add3;
  CSVString := 'IntegerProperty,StringProperty'#$D#$A'1,12345'#$D#$A'2,12345'#$D#$A'3,12345'#$D#$A;
  CheckEquals(CSVString, FBase2List.Serialize(TgSerializerCSV));
end;

procedure TestTBase2List.SerializeJSON;
var
  JSONString: string;
begin
  Add3;
  JSONString :=
  '{"ClassName":"TestgCore.TBase2List","List":[{"ClassName":"TestgCore.TBase2'+
  '","IntegerProperty":"1","StringProperty":"12345"},{"ClassName":"TestgCore.'+
  'TBase2","IntegerProperty":"2","StringProperty":"12345"},{"ClassName":"Test'+
  'gCore.TBase2","IntegerProperty":"3","StringProperty":"12345"}]}';
  CheckEquals(JSONString, FBase2List.Serialize(TgSerializerJSON));
end;

procedure TestTBase2List.DeserializeXML;
var
  XMLString: string;
begin
  XMLString :=
    '<xml>'#13#10 + //0
    '  <Base2List classname="TestgCore.TBase2List">'#13#10 + //1
    '    <List>'#13#10 + //2
    '      <Base2 classname="TestgCore.TBase2">'#13#10 + //3
    '        <IntegerProperty>1</IntegerProperty>'#13#10 + //4
    '        <StringProperty>12345</StringProperty>'#13#10 + //5
    '      </Base2>'#13#10 + //6
    '      <Base2 classname="TestgCore.TBase2">'#13#10 + //7
    '        <IntegerProperty>2</IntegerProperty>'#13#10 + //8
    '        <StringProperty>12345</StringProperty>'#13#10 + //9
    '      </Base2>'#13#10 + //10
    '      <Base2 classname="TestgCore.TBase2">'#13#10 + //11
    '        <IntegerProperty>3</IntegerProperty>'#13#10 + //12
    '        <StringProperty>12345</StringProperty>'#13#10 + //13
    '      </Base2>'#13#10 + //14
    '    </List>'#13#10 + //15
    '  </Base2List>'#13#10 + //16
    '</xml>'#13#10; //17
  FBase2List.Deserialize(TgSerializerXML, XMLString);
  CheckEquals(3, FBase2List.Items[2].IntegerProperty);
end;

procedure TestTBase2List.DeserializeCSV;
var
  CSVString: string;
begin
  CSVString := 'IntegerProperty,StringProperty'#$D#$A'1,12345'#$D#$A'2,12345'#$D#$A'3,12345'#$D#$A;
  FBase2List.Deserialize(TgSerializerCSV, CSVString);
  CheckEquals(3, FBase2List.Items[2].IntegerProperty);
end;

procedure TestTBase2List.DeserializeJSON;
var
  JSONString: string;
begin
  JSONString :=
  '{"ClassName":"TestgCore.TBase2List","List":[{"ClassName":"TestgCore.TBase2'+
  '","IntegerProperty":"1","StringProperty":"12345"},{"ClassName":"TestgCore.'+
  'TBase2","IntegerProperty":"2","StringProperty":"12345"},{"ClassName":"Test'+
  'gCore.TBase2","IntegerProperty":"3","StringProperty":"12345"}]}';
  FBase2List.Deserialize(TgSerializerJSON, JSONString);
  CheckEquals(3, FBase2List.Items[2].IntegerProperty);
end;

procedure TestTBase2List.Filter;
begin
  Add3;
  FBase2List.Where := 'IntegerProperty > 1';
  FBase2List.Filter;
  CheckEquals(2, FBase2List.Count);
  CheckEquals(2, FBase2List.Current.IntegerProperty);
end;

procedure TestTBase2List.SetValueInvalidIndex;
begin
  FBase2List.Values['[xyz].IntegerProperty'] := 2;
end;

procedure TestTBase2List.SetCurrentIndexTooHigh;
begin
  FBase2List.CurrentIndex := FBase2List.Count;
end;

procedure TestTBase2List.SetCurrentIndexTooLow;
begin
  FBase2List.CurrentIndex := -1;
end;

procedure TestTBase2List.SetUp;
begin
  FBase2List := TBase2List.Create;
end;

procedure TestTBase2List.Sort;
begin
  Add3;
  FBase2List.OrderBy := 'StringProperty, IntegerProperty DESC';
  FBase2List.Sort;
  FBase2List.First;
  CheckEquals(3, FBase2List.Current.IntegerProperty);
  FBase2List.Next;
  CheckEquals(2, FBase2List.Current.IntegerProperty);
  FBase2List.Next;
  CheckEquals(1, FBase2List.Current.IntegerProperty);
end;

procedure TestTBase2List.TearDown;
begin
  FBase2List.Free;
  FBase2List := nil;
end;

procedure TestTBase2List.TestCreate(BOL: Integer; const Value: string);
begin
  CheckEquals(0, FBase2List.Count, 'A list has no items after it gets created.');
  CheckEquals(-1, FBase2List.CurrentIndex, 'The CurrentIndex is set to -1 if there are no list items.');
end;

procedure ValidatePhone.Execute(AObject: TgObject; ARTTIProperty: TRttiProperty);
var
  ValueLength: Integer;
begin
  ValueLength := Length(AObject[ARTTIProperty.Name]);
  if InRange(ValueLength, 1, 6) then
    AObject.ValidationErrors[ARTTIProperty.Name] := 'A phone number must contain at least seven digits.';
end;

procedure TestTIdentityObject.Delete;
begin
  FIdentityObject.ID := 1;
  FIdentityObject.Name := 'One';
  FIdentityObject.Save;
  FIdentityObject.ID := 2;
  FIdentityObject.Name := 'Two';
  FIdentityObject.Save;
  FIdentityObject.ID := 3;
  FIdentityObject.Name := 'Three';
  FIdentityObject.Save;

  FIdentityObject.ID := 1;
  FIdentityObject.Load;
  FIdentityObject.Delete;
  FIdentityObject.ID := 1;
  CheckFalse(FIdentityObject.Load);

  FIdentityObject.ID := 3;
  CheckTrue(FIdentityObject.Load);
  FIdentityObject.Delete;
  FIdentityObject.ID := 3;
  CheckFalse(FIdentityObject.Load);
end;

procedure TestTIdentityObject.Save;
begin
  FIdentityObject.ID := 1;
  FIdentityObject.Name := 'One';
  FIdentityObject.Save;
  FIdentityObject.ID := 2;
  FIdentityObject.Name := 'Two';
  FIdentityObject.Save;
  FIdentityObject.ID := 3;
  FIdentityObject.Name := 'Three';
  FIdentityObject.Save;

  FIdentityObject.ID := 1;
  CheckTrue(FIdentityObject.Load);
  CheckEquals('One', FIdentityObject.Name);

  FIdentityObject.ID := 2;
  CheckTrue(FIdentityObject.Load);
  CheckEquals('Two', FIdentityObject.Name);

  FIdentityObject.ID := 3;
  CheckTrue(FIdentityObject.Load);
  CheckEquals('Three', FIdentityObject.Name);

  CheckException(SaveWithoutName, EgValidation);
end;

procedure TestTIdentityObject.SaveWithoutName;
begin
  FIdentityObject.ID := 4;
  FIdentityObject.Name := '';
  FIdentityObject.Save
end;

procedure TestTIdentityObject.SetUp;
begin
  FIdentityObject := TIdentityObject.Create;
  FIdentityObject.PersistenceManager.CreatePersistentStorage;
end;

procedure TestTIdentityObject.TearDown;
begin
  FIdentityObject.Free;
  FIdentityObject := nil;
end;

procedure TestTIdentityObjectList.Add;
begin
  Add3;
  CheckEquals(3, FIdentityObjectList.Count, 'There should be 3 items in the list.');
  CheckEquals(3, FIdentityObjectList.Current.ID, 'The last item added should be the current one.');
  CheckEquals(2, FIdentityObjectList.CurrentIndex, 'The CurrentIndex value should be one less than the count.');
  CheckEquals(TIdentityObject, FIdentityObjectList.Current.ClassType, 'Constructs the new list item from ItemClass, which in this case, is the generic class.');
end;

procedure TestTIdentityObjectList.Add3;
const
  Names : Array[1..3] of String = ('One', 'Two', 'Three');
var
  Counter: Integer;
begin
  for Counter := 1 to 3 do
  Begin
    FIdentityObjectList.Add;
    FIdentityObjectList.Current.ID := Counter;
    FIdentityObjectList.Current.Name := Names[Counter];
    FIdentityObjectList.Current.Save;
  End;
end;

procedure TestTIdentityObjectList.BOL;
begin
  CheckTrue(FIdentityObjectList.BOL, 'When there are no items, BOL should be true.');
  Add3;
  FIdentityObjectList.Active := False;
  CheckTrue(FIdentityObjectList.BOL, 'When a list gets activated its current item should be the the first item');
end;

procedure TestTIdentityObjectList.EOL;
begin
  CheckTrue(FIdentityObjectList.EOL, 'When there are no items, EOL should be true.');
  Add3;
  FIdentityObjectList.Active := False;
  CheckFalse(FIdentityObjectList.EOL, 'When a list gets activated its current item should be the the first item');
end;

procedure TestTIdentityObjectList.Count;
begin
  CheckEquals(0, FIdentityObjectList.Count, 'When a list is created it has no items');
  Add3;
  CheckEquals(3, FIdentityObjectList.Count, 'After add3, there should be three items');
  CheckFalse(FIdentityObjectList.Active, 'We should be able to get the count from the persistence manager without activating the list.');
  FIdentityObjectList.Delete;
  CheckTrue(FIdentityObjectList.Active, 'The delete should have called Current which should have activated the list.');
  CheckEquals(2, FIdentityObjectList.Count, 'Here, the count should come from the list instead of the persistence manager.');
end;

procedure TestTIdentityObjectList.Current;
begin
  CheckException(CurrentOnEmptyList,TgList.EgList, 'Calling Current on an empty list should cause an exception.');
  Add3;
  FIdentityObjectList.First;
  FIdentityObjectList.Next;
  CheckEquals(2, FIdentityObjectList.Current.ID, 'If there are items in the list, Current returns the item at CurrentIndex (zero based).');
end;

procedure TestTIdentityObjectList.CurrentOnEmptyList;
begin
  FIdentityObjectList.Current;
end;

procedure TestTIdentityObjectList.Delete;
begin
  Add3;
  FIdentityObjectList.Active := True;
  FIdentityObjectList.CurrentIndex := 1;
  FIdentityObjectList.Delete;
  CheckEquals(2, FIdentityObjectList.Count, 'Deleting one of the 3 list items should yield a count of 2.');
  CheckEquals(3, FIdentityObjectList.Current.ID, 'The 3rd item should have taken the place of the 2nd');
end;

procedure TestTIdentityObjectList.DeserializeCSV;
var
  CSVString: string;
begin
  CSVString :=
     'ID,Name'#13#10
    +'1,One'#13#10
    +'2,Two'#13#10
    +'3,Three'#13#10
    ;
  FIdentityObjectList.Deserialize(TgSerializerCSV, CSVString);
  CheckEquals(3, FIdentityObjectList.Items[2].ID);
end;

procedure TestTIdentityObjectList.DeserializeJSON;
var
  JSONString: string;
begin
  JSONString :=
  '{"ClassName":"TestgCore.TIdentityObjectList","List":[{"ClassName":"TestgCore'+
  '.TIdentityObject","ID":"1","Name":"One"},{"ClassName":"TestgCore.TIdentityOb'+
  'ject","ID":"2","Name":"Two"},{"ClassName":"TestgCore.TIdentityObject","ID":"'+
  '3","Name":"Three"}]}';
  FIdentityObjectList.Deserialize(TgSerializerJSON, JSONString);
  CheckEquals(3, FIdentityObjectList.Items[2].ID);
end;

procedure TestTIdentityObjectList.DeserializeXML;
var
  XMLString: string;
begin
  XMLString :=
    '<xml>'#13#10 + //0
    '  <IdentityObjectList classname="TestgCore.TIdentityObjectList">'#13#10 + //1
    '    <List>'#13#10 + //2
    '      <IdentityObject classname="TestgCore.TIdentityObject">'#13#10 + //3
    '        <ID>1</ID>'#13#10 + //4
    '        <Name>One</Name>'#13#10 + //5
    '      </IdentityObject>'#13#10 + //6
    '      <IdentityObject classname="TestgCore.TIdentityObject">'#13#10 + //7
    '        <ID>2</ID>'#13#10 + //8
    '        <Name>Two</Name>'#13#10 + //9
    '      </IdentityObject>'#13#10 + //10
    '      <IdentityObject classname="TestgCore.TIdentityObject">'#13#10 + //11
    '        <ID>3</ID>'#13#10 + //12
    '        <Name>Three</Name>'#13#10 + //13
    '      </IdentityObject>'#13#10 + //14
    '    </List>'#13#10 + //15
    '  </IdentityObjectList>'#13#10 + //16
    '</xml>'#13#10; //17
  FIdentityObjectList.Deserialize(TgSerializerXML, XMLString);
  CheckEquals(3, FIdentityObjectList.Items[2].ID);
end;

procedure TestTIdentityObjectList.Filter;
begin
  Add3;
  FIdentityObjectList.Active := False;
  FIdentityObjectList.Where := 'ID > 1';
  CheckEquals(2, FIdentityObjectList.Count);
  CheckFalse(FIdentityObjectList.Active, 'We should be able to get the count without activating.');
  CheckEquals(2, FIdentityObjectList.Current.ID, 'The filter should have removed ID 1.');
  CheckTrue(FIdentityObjectList.Active, 'Calling Current should activate the list.')
end;

procedure TestTIdentityObjectList.ForInEmpty;
var
  Item: TgIdentityObject;
  Items: TgIdentityList<TIdentityObject>;
begin
  Items := TgIdentityList<TIdentityObject>.Create;
  for Item in Items do
    CheckFalse(True,'The list should be empty');
  Items.Free;
end;

procedure TestTIdentityObjectList.SerializeCSV;
var
  CSVString: string;
begin
  Add3;
  CSVString :=
     'ID,Name'#13#10
    +'1,One'#13#10
    +'2,Two'#13#10
    +'3,Three'#13#10
    ;
  CheckEquals(CSVString, FIdentityObjectList.Serialize(TgSerializerCSV));
end;

procedure TestTIdentityObjectList.SerializeJSON;
var
  JSONString: string;
begin
  Add3;
  JSONString :=
  '{"ClassName":"TestgCore.TIdentityObjectList","List":[{"ClassName":"TestgCore'+
  '.TIdentityObject","ID":"1","Name":"One"},{"ClassName":"TestgCore.TIdentityOb'+
  'ject","ID":"2","Name":"Two"},{"ClassName":"TestgCore.TIdentityObject","ID":"'+
  '3","Name":"Three"}]}';
  CheckEquals(JSONString, FIdentityObjectList.Serialize(TgSerializerJSON));
end;

procedure TestTIdentityObjectList.SerializeXML;
var
  XMLString: string;
begin
  Add3;
  XMLString :=
    '<xml>'#13#10 + //0
    '  <IdentityObjectList classname="TestgCore.TIdentityObjectList">'#13#10 + //1
    '    <List>'#13#10 + //2
    '      <IdentityObject classname="TestgCore.TIdentityObject">'#13#10 + //3
    '        <ID>1</ID>'#13#10 + //4
    '        <Name>One</Name>'#13#10 + //5
    '      </IdentityObject>'#13#10 + //6
    '      <IdentityObject classname="TestgCore.TIdentityObject">'#13#10 + //7
    '        <ID>2</ID>'#13#10 + //8
    '        <Name>Two</Name>'#13#10 + //9
    '      </IdentityObject>'#13#10 + //10
    '      <IdentityObject classname="TestgCore.TIdentityObject">'#13#10 + //11
    '        <ID>3</ID>'#13#10 + //12
    '        <Name>Three</Name>'#13#10 + //13
    '      </IdentityObject>'#13#10 + //14
    '    </List>'#13#10 + //15
    '  </IdentityObjectList>'#13#10 + //16
    '</xml>'#13#10; //17
  CheckEquals(XMLString, FIdentityObjectList.Serialize(TgSerializerXML));
end;

procedure TestTIdentityObjectList.SetUp;
begin
  FIdentityObjectList := TIdentityObjectList.Create;
  FIdentityObjectList.OrderBy := 'ID';
  TgIdentityObjectClass(FIdentityObjectList.ItemClass).PersistenceManager.CreatePersistentStorage;
end;

procedure TestTIdentityObjectList.TearDown;
begin
  FIdentityObjectList.Free;
  FIdentityObjectList := nil;
end;

procedure TestTBase3.Add3;
Const
  Letters: Array[1..3] of Char = ('A', 'B', 'C');
var
  Counter: Integer;
begin
  for Counter := 1 to 3 do
  begin
    Base3.List.Add;
    Base3.List.Current.IntegerProperty := Counter;
    Base3.List.Current.StringProperty := Letters[Counter];
  end;
end;

procedure TestTBase3.SerializeCSV;
var
  CSVString: string;
begin
  Base3.Name := 'One';
  Add3;
  CSVString :=
    'IntegerProperty,StringProperty,Name,List.Count,List[0].IntegerProperty,List[0].StringProperty,List[1].IntegerProperty,List[1].StringProperty,List[2].IntegerProperty,List[2].StringProperty'#$D#$A
   +'2,12345,One,3,1,A,2,B,3,C'#$D#$A;
  CheckEquals(CSVString, Base3.Serialize(TgSerializerCSV));
end;

procedure TestTBase3.SerializeXML;
var
  XMLString: string;
begin
  Base3.Name := 'One';
  Add3;
  XMLString :=
    '<xml>'#13#10 + //0
    '  <Base3 classname="TestgCore.TBase3">'#13#10 + //1
    '    <IntegerProperty>2</IntegerProperty>'#13#10 + //2
    '    <StringProperty>12345</StringProperty>'#13#10 + //3
    '    <Name>One</Name>'#13#10 + //4
    '    <List classname="TestgCore.TBase2List">'#13#10 + //5
    '      <List>'#13#10 + //6
    '        <Base2 classname="TestgCore.TBase2">'#13#10 + //7
    '          <IntegerProperty>1</IntegerProperty>'#13#10 + //8
    '          <StringProperty>A</StringProperty>'#13#10 + //9
    '        </Base2>'#13#10 + //10
    '        <Base2 classname="TestgCore.TBase2">'#13#10 + //11
    '          <IntegerProperty>2</IntegerProperty>'#13#10 + //12
    '          <StringProperty>B</StringProperty>'#13#10 + //13
    '        </Base2>'#13#10 + //14
    '        <Base2 classname="TestgCore.TBase2">'#13#10 + //15
    '          <IntegerProperty>3</IntegerProperty>'#13#10 + //16
    '          <StringProperty>C</StringProperty>'#13#10 + //17
    '        </Base2>'#13#10 + //18
    '      </List>'#13#10 + //19
    '    </List>'#13#10 + //20
    '  </Base3>'#13#10 + //21
    '</xml>'#13#10; //22
  CheckEquals(XMLString, Base3.Serialize(TgSerializerXML));
end;

procedure TestTBase3.DeserializeCSV;
var
  CSVString: string;
begin
  CSVString :=
    'IntegerProperty,StringProperty,Name,List.Count,List[0].IntegerProperty,List[0].StringProperty,List[1].IntegerProperty,List[1].StringProperty,List[2].IntegerProperty,List[2].StringProperty'#$D#$A
   +'2,12345,One,3,1,A,2,B,3,C'#$D#$A;
  Base3.Deserialize(TgSerializerCSV, CSVString);
  CheckEquals('One', Base3.Name);
  CheckEquals('C', Base3.List[2].StringProperty);
end;

procedure TestTBase3.DeserializeXML;
var
  XMLString: string;
begin
  XMLString :=
    '<xml>'#13#10 + //0
    '  <Base3 classname="TestgCore.TBase3">'#13#10 + //1
    '    <IntegerProperty>2</IntegerProperty>'#13#10 + //2
    '    <StringProperty>12345</StringProperty>'#13#10 + //3
    '    <Name>One</Name>'#13#10 + //4
    '    <List classname="TestgCore.TBase2List">'#13#10 + //5
    '      <List>'#13#10 + //6
    '        <Base2 classname="TestgCore.TBase2">'#13#10 + //7
    '          <IntegerProperty>1</IntegerProperty>'#13#10 + //8
    '          <StringProperty>A</StringProperty>'#13#10 + //9
    '        </Base2>'#13#10 + //10
    '        <Base2 classname="TestgCore.TBase2">'#13#10 + //11
    '          <IntegerProperty>2</IntegerProperty>'#13#10 + //12
    '          <StringProperty>B</StringProperty>'#13#10 + //13
    '        </Base2>'#13#10 + //14
    '        <Base2 classname="TestgCore.TBase2">'#13#10 + //15
    '          <IntegerProperty>3</IntegerProperty>'#13#10 + //16
    '          <StringProperty>C</StringProperty>'#13#10 + //17
    '        </Base2>'#13#10 + //18
    '      </List>'#13#10 + //19
    '    </List>'#13#10 + //20
    '  </Base3>'#13#10 + //21
    '</xml>'#13#10; //22
  Base3.Deserialize(TgSerializerXML, XMLString);
  CheckEquals('One', Base3.Name);
  CheckEquals('C', Base3.List[2].StringProperty);
end;

procedure TestTBase3.PathName;
begin
  Base3.Name := 'One';
  Add3;
  Base3.List.Previous;
  CheckEquals('List[1]', Base3.List.Current.PathName);
  CheckEquals(2, Base3[Base3.List.Current.PathName + '.IntegerProperty']);
end;

procedure TestTBase3.SetUp;
begin
  inherited;
  Base3 := TBase3.Create;
end;

procedure TestTBase3.TearDown;
begin
  Base3.Free;
  inherited;
end;

procedure TestTIDObject.Save;
begin
  IDObject.Name := 'One';
  IDObject.Save;
  CheckEquals(1, IDObject.ID);
end;

procedure TestTIDObject.SaveChanges;
var
  IDObject1: TIDObject;
  IDObject2: TIDObject;
begin
  IDObject.Name := 'Name';
  IDObject.Name2 := 'Name2';
  IDObject.Save;
  IDObject1 := TIDObject.Create;
  IDObject2 := TIDObject.Create;
  try
    IDObject1.ID := 1;
    IDObject1.Load;
    IDObject2.ID := 1;
    IDObject2.Load;

    IDObject1.Name := 'One';
    IDObject1.Save;

    IDObject2.Name2 := 'Two';
    IDObject2.Save;
  finally
    IDObject2.Free;
    IDObject1.Free;
  end;

  IDObject.Load;
  CheckEquals('One', IDObject.Name, 'Value from first field');
  CheckEquals('Two', IDObject.Name2, 'Value from second field');

end;

procedure TestTIDObject.SetUp;
begin
  inherited;
  TIDObject.PersistenceManager.CreatePersistentStorage;
  IDObject := TIDObject.Create;
end;

procedure TestTIDObject.TearDown;
begin
  IDObject.Free;
  inherited;
end;

procedure TestTIDObject2.Add3Items;
const
  Names : Array[1..3] of String = ('One', 'Two', 'Three');
var
  Counter: Integer;
begin
  for Counter := 1 to 3 do
  begin
    FIDObject2.IDObjects.Add;
    FIDObject2.IDObjects.Current.Name := Names[Counter];
    FIDObject2.IDObjects.Current.Save;
  end;
end;

procedure TestTIDObject2.ExtendedWhere;
begin
  FIDObject2.Name := 'One';
  FIDObject2.IDObject.ID := 1;
  FIDObject2.Save;
  Add3Items;
  FIDObject2.RemoveIdentity;
  FIDObject2.Name := 'Two';
  FIDObject2.IDObject.ID := 2;
  FIDObject2.Save;
  Add3Items;
  FIDObject2.ID := 1;
  FIDObject2.Load;
  FIDObject2.IDObjects.First;
  CheckEquals(3, FIDObject2.IDObjects.Count);
  CheckEquals(1, FIDObject2.IDObjects.Current.ID);
  FIDObject2.ID := 2;
  FIDObject2.Load;
  FIDObject2.IDObjects.First;
  CheckEquals(3, FIDObject2.IDObjects.Count);
  CheckEquals(4, FIDObject2.IDObjects.Current.ID);
end;

procedure TestTIDObject2.Save;
begin
  FIDObject2.Name := 'One';
  FIDObject2.IDObject.ID := 1;
  FIDObject2.Save;
  FIDObject2.RemoveIdentity;
  FIDObject2.Name := 'Two';
  FIDObject2.IDObject.ID := 2;
  FIDObject2.Save;
  FIDObject2.ID := 1;
  FIDObject2.Load;
  CheckEquals(1, FIDObject2.IDObject.ID);
end;

procedure TestTIDObject2.SaveItem;
begin
  FIDObject2.Name := 'One';
  FIDObject2.IDObject.ID := 1;
  FIDObject2.Save;
  FIDObject2.IDObjects.Add;
  FIDObject2.IDObjects.Current.Name := 'One';
  FIDObject2.IDObjects.Current.Save;
end;

procedure TestTIDObject2.SetUp;
begin
  inherited;
  FIDObject := TIDObject.Create;
  FIDObject.PersistenceManager.CreatePersistentStorage;
  FIDObject.Name := 'A';
  FIDObject.Save;
  FIDObject.ID := 0;
  FIDObject.Name := 'B';
  FIDObject.Save;
  FIDObject2 := TIDObject2.Create;
  FIDObject2.PersistenceManager.CreatePersistentStorage;
  TIDObject3.PersistenceManager.CreatePersistentStorage;
end;

procedure TestTIDObject2.TearDown;
begin
  FIDObject.Free;
  FIDObject2.Free;
  inherited;
end;

{ TestTSerializeCSV }

procedure TestTSerializeCSV.SetUp;
begin
  inherited;
  FSerializer := TgSerializerCSV.Create;
end;

procedure TestTSerializeCSV.Deserialize;
var
  Item: TgTest;
begin
  Item := TgTest.Create;
  FSerializer.Deserialize(Item,'Name,Price'#$D#$A'Judy,34.23'#$D#$A);
  CheckEquals('Judy',Item.Name);
  CheckEquals(34.23,Item.Price);
  FreeAndNil(Item);
end;

procedure TestTSerializeCSV.DeserializeArr;
var
  Item: TgTest;
begin
  Item := TgTest.Create;
  FSerializer.Deserialize(Item,'Name,Price,Names.Count,Names[0].Name,Names[1].Name'#$D#$A'Judy,34.23,2,Hello,There'#$D#$A);
  CheckEquals('Judy',Item.Name);
  CheckEquals(34.23,Item.Price);
  CheckEquals(2,Item.Names.Count);
  CheckEquals('Hello',Item.Names[0].Name);
  CheckEquals('There',Item.Names[1].Name);
  FreeAndNil(Item);

end;

procedure TestTSerializeCSV.DeserializeCRLF;
var
  List: TgList<TgTest>;
  S: String;
begin
  S := 'Name,Price'#$D#$A'"Jim'#$A'Barney",12.3'#$D#$A'"Fred'#$A'Mosbie",50'#$D#$A;
  List := TgList<TgTest>.Create;
  FSerializer.Deserialize(List,S);
  List.First;
  CheckFalse(List.EOL);
  CheckEquals('Jim',List.Current.Name);
  CheckEquals(12.30,List.Current.Price);
  List.Next;
  CheckFalse(List.EOL);
  CheckEquals('Fred',List.Current.Name);
  CheckEquals(50,List.Current.Price);
  List.Next;
  CheckTrue(List.EOL);
  FreeAndNil(List);
end;

procedure TestTSerializeCSV.DeserializeList;
var
  List: TgList<TgTest>;
  S: String;
begin
  S := 'Name,Price'#$D#$A'Jim,12.3'#$D#$A'Fred,50'#$D#$A;
  List := TgList<TgTest>.Create;
  FSerializer.Deserialize(List,S);
  List.First;
  CheckFalse(List.EOL);
  CheckEquals('Jim',List.Current.Name);
  CheckEquals(12.30,List.Current.Price);
  List.Next;
  CheckFalse(List.EOL);
  CheckEquals('Fred',List.Current.Name);
  CheckEquals(50,List.Current.Price);
  List.Next;
  CheckTrue(List.EOL);
  FreeAndNil(List);
end;

procedure TestTSerializeCSV.Serialize;
var
  Item: TgTest;
  S: String;
begin
  Item := TgTest.Create;
  Item.Name := 'Judy';
  Item.Price := 34.23;
  CheckEquals('Name,Price'#$D#$A'Judy,34.23'#$D#$A,FSerializer.Serialize(Item));
  Item.Names.Add;
  Item.Names.Current.Name := 'Hello';
  Item.Names.Add;
  Item.Names.Current.Name := 'There';
  S := FSerializer.Serialize(Item);
  CheckEquals('Name,Price,Names.Count,Names[0].Name,Names[1].Name'#$D#$A'Judy,34.23,2,Hello,There'#$D#$A,S);
  FreeAndNil(Item);
end;

procedure TestTSerializeCSV.SerializeCRLF;
var
  List: TgList<TgTest>;
  S: String;
begin
  List := TgList<TgTest>.Create;
  List.Add;
  List.Current.Name := 'Jim'#10'Barney';
  List.Current.Price := 12.30;
  List.Add;
  List.Current.Name := 'Fred'#10'Mosbie';
  List.Current.Price := 50;
  S := FSerializer.Serialize(List);
  CheckEquals('Name,Price'#$D#$A'"Jim'#$A'Barney",12.3'#$D#$A'"Fred'#$A'Mosbie",50'#$D#$A,S);
  FreeAndNil(List);
end;

procedure TestTSerializeCSV.SerializeList;
var
  List: TgList<TgTest>;
  S: String;
begin
  List := TgList<TgTest>.Create;
  List.Add;
  List.Current.Name := 'Jim';
  List.Current.Price := 12.30;
  List.Add;
  List.Current.Name := 'Fred';
  List.Current.Price := 50;
  S := FSerializer.Serialize(List);
  CheckEquals('Name,Price'#$D#$A'Jim,12.3'#$D#$A'Fred,50'#$D#$A,S);
  FreeAndNil(List);
end;

procedure TestTSerializeCSV.TearDown;
begin
  FreeAndNil(FSerializer);
  inherited;
end;

(*
{ TestTgNodeCSV }

procedure TestTgNodeCSV.ColumnName;
begin
  FNode.Values['Name'] := 'Jim';
  FNode.Values['Price'] := '12.50';
end;

procedure TestTgNodeCSV.NestedColumnName;
var Node: TgNodeCSV;
begin
  FNode.Add('Name','Jim');
  FNode.Add('Price','12.50');
  CheckEquals('Name',FNode.ColumnNames[0]);
  CheckEquals('Price',FNode.ColumnNames[1]);
  Node := FNode.AddChild('SubStuff');
  Node.Add('Item','Juice');
  Node.Add('Category','Liquid');
  CheckEquals('SubStuff.Item',Node.ColumnNames[0]);
  CheckEquals('SubStuff.Category',Node.ColumnNames[1]);
end;

procedure TestTgNodeCSV.SetUp;
begin
  inherited;
  FNode := TgNodeCSV.Create(nil);
end;

procedure TestTgNodeCSV.TearDown;

begin
  FNode.Free;
  inherited;
end;
*)
{ TestTSerializeCSV.TgTest }


constructor TestTSerializeCSV.TgTest.Create(AOwner: TgBase);
begin
  inherited;
  FNames := TgList<TgName>.Create(Self);
end;

{ TestHTMLParser }

procedure TestHTMLParser.AssignTag;
var
  Text: String;
  gCustomer: TCustomer;
begin
  gCustomer := TCustomer.Create;
  try
    CheckEquals('',gCustomer.FirstName);
    Text :=
  //     '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'#13#10+
  //    '<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Untitled <b>Document</b>S</title></head><body></body></html>';
      '<html xmlns="http://www.w3.org/1999/xhtml">'#$D#$A+
      '  <head xmlns="">'#$D#$A+
      '    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>'#$D#$A+
      '    <title>Untitled   <b>Document</b>'#$D#$A+
      '    S</title>'#$D#$A+
      '  </head>'#$D#$A+
      '  <body>'#$D#$A+
      '    <assign condition="GoodCustomer" Name="FirstName" value="DeadMeat" />'#$D#$A+
      '  </body>'#$D#$A+
      '</html>'#$D#$A;
    gCustomer.GoodCustomer := False;
    CheckEquals('<html xmlns="http://www.w3.org/1999/xhtml">'#$D#$A'  <head xmlns="">'#$D#$A'    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>'#$D#$A'    <title>Untitled     <b>Document</b>'#$D#$A'    '#$D#$A'    S</title>'#$D#$A'  </head>'#$D#$A'  <body xmlns=""/>'#$D#$A'</html>'#$D#$A,TgDocument._ProcessText(Text,gCustomer));
    CheckEquals('',gCustomer.FirstName);
    gCustomer.GoodCustomer := True;
    CheckEquals('<html xmlns="http://www.w3.org/1999/xhtml">'#$D#$A'  <head xmlns="">'#$D#$A'    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>'#$D#$A'    <title>Untitled     <b>Document</b>'#$D#$A'    '#$D#$A'    S</title>'#$D#$A'  </head>'#$D#$A'  <body xmlns=""/>'#$D#$A'</html>'#$D#$A,TgDocument._ProcessText(Text,gCustomer));
    CheckEquals('DeadMeat',gCustomer.FirstName);
  finally
    gCustomer.Free;
  end;

end;

procedure TestHTMLParser.Convert1;
var
  Text: String;
begin
  Text :=
//     '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'#13#10+
//    '<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Untitled <b>Document</b>S</title></head><body></body></html>';
    '<html xmlns="http://www.w3.org/1999/xhtml">'#$D#$A+
    '  <head xmlns="">'#$D#$A+
    '    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>'#$D#$A+
    '    <title>Untitled   <b>Document</b>'#$D#$A+
    '    S</title>'#$D#$A+
    '  </head>'#$D#$A+
    '  <body xmlns=""/>'#$D#$A+
    '</html>'#$D#$A;

  CheckEquals(
    '<html xmlns="http://www.w3.org/1999/xhtml">'#$D#$A
   +'  <head xmlns="">'#$D#$A
   +'    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>'#$D#$A
   +'    <title>Untitled     <b>Document</b>'#$D#$A
   +'    '#$D#$A
   +'    S</title>'#$D#$A
   +'  </head>'#$D#$A
   +'  <body xmlns=""/>'#$D#$A
   +'</html>'#$D#$A
  ,TgDocument._ProcessText(Text));
end;

procedure TestHTMLParser.HTMLField;
var
  Customer: TCustomer;
  Text: String;
begin
  Customer := TCustomer.Create;
  try
    Customer.FirstName := 'David';
    Customer.Webcontent := '<b>{FirstName}</b><br />{LastName}';
    Customer.Notes := '<b>{FirstName}'#13#10'{LastName}</b>';
    Text := '<html><div>{WebContent}</div><div>{Notes}</div></html>';
    CheckEquals('',TgDocument._ProcessText(Text,Customer));
  finally
    FreeAndNil(Customer);
  end;
end;

procedure TestTFirebirdObject.Save;
var
  NewFirebirdObject: TFirebirdObject;
begin
  FFirebirdObject.Name := 'One';
  FFirebirdObject.Save;
  NewFirebirdObject := TFirebirdObject.Create;
  try
    NewFirebirdObject.ID := FFirebirdObject.ID;
    CheckTrue(NewFirebirdObject.Load);
    NewFirebirdObject.Name := 'Two';
    NewFirebirdObject.Save;
  finally
    NewFirebirdObject.Free;
  end;
  NewFirebirdObject := TFirebirdObject.Create;
  try
    NewFirebirdObject.ID := FFirebirdObject.ID;
    NewFirebirdObject.Load;
    CheckEquals('Two', NewFirebirdObject.Name);
    NewFirebirdObject.Delete;
  finally
    NewFirebirdObject.Free;
  end;
  NewFirebirdObject := TFirebirdObject.Create;
  try
    NewFirebirdObject.ID := FFirebirdObject.ID;
    CheckFalse(NewFirebirdObject.Load);
  finally
    NewFirebirdObject.Free;
  end;
end;

{ TestTFirebirdObject }

procedure TestTFirebirdObject.SetUp;
begin
  inherited;
  FFirebirdObject := TFirebirdObject.Create;
end;

procedure TestTFirebirdObject.TearDown;
begin
  FreeAndNil(FFirebirdObject);
  inherited;
end;

procedure TestHTMLParser.ifTag;
var
  Text: String;
  gCustomer: TCustomer;
begin
  gCustomer := TCustomer.Create;
  gCustomer.FirstName := 'Steve';
  gCustomer.LastName := 'Nooner';
  try
    Text :=
       '<html xmlns="http://www.w3.org/1999/xhtml">'#13#10
      +'<if condition="GoodCustomer">'#13#10
        +'Hello'#13#10
        +'<then>{FirstName}, You are awesome!</then>'#13#10
        +'<else>{LastName}, Try to do better :(</else>'#13#10
      +'</if>'#13#10
      +'</html>';
    gCustomer.GoodCustomer := True;
    CheckEquals('<html xmlns="http://www.w3.org/1999/xhtml">Steve, You are awesome!</html>'#$D#$A,TgDocument._ProcessText(Text,gCustomer));
    gCustomer.GoodCustomer := False;
    CheckEquals('<html xmlns="http://www.w3.org/1999/xhtml">Nooner, Try to do better :(</html>'#$D#$A,TgDocument._ProcessText(Text,gCustomer));

    Text :=
       '<html xmlns="http://www.w3.org/1999/xhtml">'#13#10
      +'<if condition="GoodCustomer">'#13#10
        +'{FirstName}, You are awesome!'#13#10
      +'</if>'#13#10
      +'</html>';
    gCustomer.GoodCustomer := True;
    CheckEquals('<html xmlns="http://www.w3.org/1999/xhtml">Steve, You are awesome!</html>'#$D#$A,TgDocument._ProcessText(Text,gCustomer));
    gCustomer.GoodCustomer := False;
    CheckEquals('<html xmlns="http://www.w3.org/1999/xhtml"></html>'#$D#$A,TgDocument._ProcessText(Text,gCustomer));

  finally
    gCustomer.Free;
  end;
end;

procedure TestHTMLParser.IncludeTag;
var
  Text: String;
begin
  with TStringList.Create do try
    Add('<b>{2 + 2}</b>');
    SaveToFile('YYY.hti');

    Text :=
  //     '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'#13#10
         '<html xmlns="http://www.w3.org/1999/xhtml">'#13#10
        +'<head>'#13#10
        +'<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />'#13#10
        +'<title>Untitled<b> Document</b>!</title>'#13#10
        +'</head>'#13#10
        +'<body>'#13#10
        +'<include FileName="YYY.hti" SearchPath=""/>'#13#10
        +'</body>'#13#10
        +'</html>'#13#10;
    CheckEquals(
         '<html xmlns="http://www.w3.org/1999/xhtml">'#$D#$A
        +'  <head xmlns="">'#$D#$A'    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>'#$D#$A
        +'    <title>Untitled  <b> Document</b>'#$D#$A
        +'    !</title>'#$D#$A'  </head>'#$D#$A
        +'  <body xmlns="">'#$D#$A
        +'    <b>{2 + 2}</b>'#$D#$A
        +'  </body>'#$D#$A
        +'</html>'#$D#$A
      ,TgDocument._ProcessText(Text));

  finally
    DeleteFile('YYY.hti');
    Free;
  end;

  with TStringList.Create do try
    Add('<html>{2 + 2}</html>');
    SaveToFile('YYY.hti');
    Text :=
  //     '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'#13#10
       '<html xmlns="http://www.w3.org/1999/xhtml">'#13#10
      +'<head>'#13#10
      +'<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />'#13#10
      +'<title>Untitled<b> Document</b>!</title>'#13#10
      +'</head>'#13#10
      +'<body>'#13#10
      +'<include FileName="YYY.hti" SearchPath=""/>'#13#10
      +'</body>'#13#10
      +'</html>'#13#10;
  CheckEquals('',TgDocument._ProcessText(Text));
  finally
    DeleteFile('YYY.hti');
    Free;
  end;

end;

procedure TestHTMLParser.ListTag;
var
  Text: String;
  Model: TModel;
begin
  Model := TModel.Create;
  try
    Model.Customers.Add;
    Model.Customers.Current.FirstName := 'Steve<>';
    Model.Customers.Current.LastName:= 'Joe & Jerry';
    Model.Customers.Current.WebAddress := 'http://www.google.com';
    Model.Customers.Add;
    Model.Customers.Current.FirstName := 'Jim';
    Model.Customers.Current.LastName := '<Bush>';
    Model.Customers.Current.WebAddress := 'http://www.yahoo.com';

    Text :=
  //     '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'#13#10
       '<html xmlns="http://www.w3.org/1999/xhtml">'#13#10
      +'<head>'#13#10
      +'<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />'#13#10
      +'<title>Untitled<b> Document</b>!</title>'#13#10
      +'</head>'#13#10
      +'<body>'#13#10
      +'  <b conditionSelf="Customers.Count = 1" >Count</b>'
      +'  <list condition="Customers.Count > 1" object="Customers">'#13#10 //DoList
  //    +'    <a href="{WebAddress}">{if(FirstName &lt;&gt; '',FirstName)}</a><br />'#13#10
      +'    <a href="{WebAddress}">{FirstName} {LastName}</a><br />'#13#10
  //    <div conditionself="ValidationErrors.Name" class="Error">Name</div>
      +'  </list>'#13#10
      +'</body>'#13#10
      +'</html>'#13#10;
    CheckEquals('<html xmlns="http://www.w3.org/1999/xhtml">'#$D#$A
      +'  <head xmlns="">'#$D#$A
      +'    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>'#$D#$A
      +'    <title>Untitled  <b> Document</b>'#$D#$A
      +'    !</title>'#$D#$A
      +'  </head>'#$D#$A
      +'  <body xmlns="">Count  <a href="http://www.google.com">Steve&lt;&gt; Joe &amp; Jerry</a>'#$D#$A
      +'    <br/>'#$D#$A
      +'    <a href="http://www.yahoo.com">Jim &lt;Bush&gt;</a>'#$D#$A
      +'    <br/>'#$D#$A
      +'  </body>'#$D#$A
      +'</html>'#$D#$A
    ,TgDocument._ProcessText(Text,Model));
  //  TargetDocument.SaveToXML(TextResult);
  finally
    Model.Free;
  end;

end;

procedure TestHTMLParser.Replace;
var
  Customer: TCustomer;
  Element: TgElement;
  AIsHTML: Boolean;

begin
  Customer := TCustomer.Create;
  Customer.FirstName := 'Steve';
  Customer.LastName := 'Nooner';
  Customer.WebContent := 'Hello';
  Customer.WebAddress := 'http://www.google.com';
  try
    Element := TgElement.Create;
    try
      Element.gBase := Customer;
      CheckEquals('Hello',Element.ProcessValue('Hello'));
      CheckEquals(Customer.FirstName,Element.ProcessValue('{FirstName}'));
      CheckEquals(Customer.FirstName+Customer.LastName,Element.ProcessValue('{FirstName}{LastName}'));
      CheckEquals('X'+Customer.FirstName+Customer.LastName,Element.ProcessValue('X{FirstName}{LastName}'));
      CheckEquals(Customer.FirstName+'X'+Customer.LastName,Element.ProcessValue('{FirstName}X{LastName}'));
      CheckEquals(Customer.FirstName+Customer.FirstName+'X',Element.ProcessValue('{FirstName}{FirstName}X'));
      CheckEquals('X'+Customer.FirstName+'X'+Customer.LastName+'X',Element.ProcessValue('X{FirstName}X{LastName}X'));
      CheckEquals(Customer.FirstName,Element.ProcessValue('{FirstName}'));
      CheckEquals(Customer.WebAddress,Element.ProcessValue('{WebAddress}'));
      CheckEquals(Customer.WebAddress,Element.ProcessValue('{WebAddress}'));
      CheckEquals('<p>Hi, '+Customer.FirstName+'</p>',Element.ProcessValue('<p>Hi, {FirstName}</p>'));
      CheckEquals('<p>Hi, '+Customer.FirstName+' '+Customer.LastName+'</p>',Element.ProcessValue('<p>Hi, {FirstName} {LastName}</p>'));
      CheckEquals('<p>Hi, Mr. '+Customer.LastName+'</p>',Element.ProcessValue('<p>Hi, {''Mr. '' + LastName}</p>'));
      CheckEquals(Customer.WebAddress,EvalHTML('WebAddress',Customer,AIsHTML));
      CheckFalse(AIsHTML);
      CheckEquals(Customer.WebContent,EvalHTML('WebContent',Customer,AIsHTML));
      CheckTrue(AIsHTML);

      //Evaluate('<p>Hello {Name}</p>', Customer)
    finally
      Element.Free;
    end;

  finally
    Customer.Free;
  end;

end;


procedure TestHTMLParser.WithTag;
var
  Text: String;
  gCustomer: TCustomer;
  gCustomer2: TCustomer;
begin
  gCustomer := TCustomer.Create;
  gCustomer.FirstName := 'Steve';
  gCustomer.LastName := 'Nooner';
  gCustomer2 := TCustomer.Create;
  gCustomer2.FirstName := 'Linda';
  gCustomer2.LastName := 'Evans';
  gCustomer.OtherCustomer := gCustomer2;
  try
  Text :=
//     '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'#13#10
     '<html xmlns="http://www.w3.org/1999/xhtml">'#13#10
    +'<head>'#13#10
    +'<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />'#13#10
    +'</head>'#13#10
    +'<body>'#13#10
    +'{FirstName}'#13#10
    +'<with object="OtherCustomer">'#13#10
    +'{FirstName} {LastName}'#13#10
    +'</with>'#13#10
    +'{LastName}'#13#10
    +'</body>'#13#10
    +'</html>'#13#10;
    gCustomer.GoodCustomer := True;
    CheckEquals('<html xmlns="http://www.w3.org/1999/xhtml">'#$D#$A'  <head xmlns="">'#$D#$A'    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>'#$D#$A'  </head>'#$D#$A'  <body xmlns="">'#$D#$A'Steve'#$D#$A#$D#$A'Linda Evans'#$D#$A#$D#$A'Nooner'#$D#$A'</body>'#$D#$A'</html>'#$D#$A
      ,TgDocument._ProcessText(Text,gCustomer));
(*
    gCustomer.GoodCustomer := False;
    CheckEquals('',TgElement._ProcessText(Text,gCustomer));
*)
  finally
    gCustomer.OtherCustomer := nil;
    gCustomer2.Free;
    gCustomer.Free;
  end;
end;

procedure TestEvalHTML.Eval;
var
  IsHTML: Boolean;
begin
  EvalHTML('HTMLString', TestObject, IsHTML);
  CheckTrue(IsHTML);
  EvalHTML('NonHTMLString', TestObject, IsHTML);
  CheckFalse(IsHTML);
end;

procedure TestEvalHTML.SetUp;
begin
  TestObject := TTest.Create;
end;

procedure TestEvalHTML.TearDown;
begin
  TestObject.Free;
end;

initialization

  // Register any test cases with the test runner
  RegisterTest(TestTBase.Suite);
  RegisterTest(TestTgString5.Suite);
  RegisterTest(TestTBase2List.Suite);
  RegisterTest(TestTIdentityObject.Suite);
  RegisterTest(TestTIdentityObjectList.Suite);
  RegisterTest(TestTBase3.Suite);
  RegisterTest(TestTIDObject.Suite);
  RegisterTest(TestTIDObject2.Suite);
//  RegisterTest(TestTgNodeCSV.Suite);
  RegisterTest(TestTSerializeCSV.Suite);
  RegisterTest(TestHTMLParser.Suite);
  RegisterTest(TestTFirebirdObject.Suite);
  RegisterTest(TestEvalHTML.Suite);
  RegisterRuntimeClasses([TFirebirdObject]);
  G.Initialize;
end.

