unit TestgCore;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, gCore;

type
  // Test methods for class TgBase

  TgString5 = record
  strict private
    FValue: String;
  public
    function GetValue: String;
    procedure SetValue(const AValue: String);
    class operator implicit(AValue: Variant): TgString5; overload;
    class operator Implicit(AValue: TgString5): Variant; overload;
    property Value: String read GetValue write SetValue;
  end;

  TPhoneString = record
  strict private
    FValue: String;
  public
    function FormatPhone(AValue : String): String;
    function GetValue: String;
    procedure SetValue(const AValue: String);
    class operator Implicit(AValue: TPhoneString): Variant; overload;
    class operator Implicit(AValue: Variant): TPhoneString; overload;
    property Value: String read GetValue write SetValue;
  end;

  TgBaseCustom = class(TgBase)
  strict private
    FIntegerProperty: Integer;
    FManuallyConstructedObjectProperty: TgBaseCustom;
    FObjectProperty: TgBase;
    FPhone: TPhoneString;
    FString5: TgString5;
    FStringProperty: String;
    FUnconstructedObjectProperty: TgBase;
    FUnreadableIntegerProperty: Integer;
    FUnwriteableIntegerProperty: Integer;
    function GetManuallyConstructedObjectProperty: TgBaseCustom;
  public
    destructor Destroy; override;
  published
    procedure SetUnwriteableIntegerProperty;
    [DefaultValue(5)]
    property IntegerProperty: Integer read FIntegerProperty write FIntegerProperty;
    [ExcludeFeature([AutoCreate])]
    property ManuallyConstructedObjectProperty: TgBaseCustom read GetManuallyConstructedObjectProperty;
    property ObjectProperty: TgBase read FObjectProperty;
    [DefaultValue('Test')]
    property StringProperty: String read FStringProperty write FStringProperty;
    [ExcludeFeature([AutoCreate])]
    property UnconstructedObjectProperty: TgBase read FUnconstructedObjectProperty write FUnconstructedObjectProperty;
    property UnreadableIntegerProperty: Integer write FUnreadableIntegerProperty;
    property UnwriteableIntegerProperty: Integer read FUnwriteableIntegerProperty;
    property String5: TgString5 read FString5 write FString5;
    property Phone: TPhoneString read FPhone write FPhone;
  end;

  TestTgBase = class(TTestCase)
  strict private
    FgBase: TgBaseCustom;
  public
    procedure PathEndsWithAnObjectProperty;
    procedure PathExtendsBeyondOrdinalProperty;
    procedure PropertyNotReadable;
    procedure PropertyNotWriteable;
    procedure SetPathEndsWithAnObjectProperty;
    procedure SetPathExtendsBeyondOrdinalProperty;
    procedure SetUndeclaredProperty;
    procedure SetUp; override;
    procedure TearDown; override;
    procedure UndeclaredProperty;
  published
    procedure GetValue;
    procedure SetValue;
    procedure TestAssign;
    procedure TestCreate;
  end;

  TestTgString5 = class(TTestCase)
  published
    procedure TestLength;
  end;

implementation

Uses
  SysUtils,
  Character
  ;

procedure TestTgBase.GetValue;
begin
  // Given a Pathname, return the property value
  CheckEquals('Test', FgBase['StringProperty'], 'Non-Object Property');
  CheckEquals('Test', FgBase['ManuallyConstructedObjectProperty.StringProperty'], 'Object Property');
  // If the property doesn't exist, raise an exception
  CheckException(UndeclaredProperty, EgValue);
  // If the path extends beyond an ordinal property, raise an exception
  CheckException(PathExtendsBeyondOrdinalProperty, EgValue);
  // If the path ends with an object property, raise an exception
  CheckException(PathEndsWithAnObjectProperty, EgValue);
  // If the property is not readable, raise an exception
  CheckException(PropertyNotReadable, EgValue);
  // Can we get an Active Value?
  FgBase.String5 := '123456789';
  CheckEquals('12345', FgBase['String5'], 'Active Value');
  FgBase.Phone := '5555555555';
  CheckEquals('(555) 555-5555', FgBase['Phone'], 'Phone');
end;

procedure TestTgBase.PathEndsWithAnObjectProperty;
begin
  FgBase['ObjectProperty'];
end;

procedure TestTgBase.PathExtendsBeyondOrdinalProperty;
begin
  FgBase['IntegerProperty.ThisShouldNotBeHere'];
end;

procedure TestTgBase.PropertyNotReadable;
begin
  FgBase['UnreadableIntegerProperty'];
end;

procedure TestTgBase.PropertyNotWriteable;
begin
  FgBase['UnwriteableIntegerProperty'] := 5;
end;

procedure TestTgBase.SetPathEndsWithAnObjectProperty;
begin
  FgBase['ObjectProperty'] := 'Test';
end;

procedure TestTgBase.SetPathExtendsBeyondOrdinalProperty;
begin
  FgBase['IntegerProperty.ThisShouldNotBeHere'] := 'Test';
end;

procedure TestTgBase.SetUndeclaredProperty;
begin
  FgBase['ThisPropertyDoesNotExist'] := 'Test';
end;

procedure TestTgBase.SetUp;
begin
  FgBase := TgBaseCustom.Create;
end;

procedure TestTgBase.SetValue;
begin
  // Given a Pathname, set the property value
  FgBase['StringProperty'] := 'Test2';
  CheckEquals('Test2', FgBase['StringProperty'], 'Non-Object Property');
  FgBase['ManuallyConstructedObjectProperty.StringProperty'] := 'Test2';
  CheckEquals('Test2', FgBase['ManuallyConstructedObjectProperty.StringProperty'], 'Object Property');
  // If the property doesn't exist, raise an exception
  CheckException(SetUndeclaredProperty, EgValue);
  // If the path extends beyond an ordinal property, raise an exception
  CheckException(SetPathExtendsBeyondOrdinalProperty, EgValue);
  // If the path ends with an object property, raise an exception
  CheckException(SetPathEndsWithAnObjectProperty, EgValue);
  // If the property is not writeable, raise an exception
  CheckException(PropertyNotWriteable, EgValue);
  // Call a method
  FgBase['SetUnwriteableIntegerProperty'] := '';
  CheckEquals(10, FgBase.UnwriteableIntegerProperty);
  FgBase['ManuallyConstructedObjectProperty.SetUnwriteableIntegerProperty'] := '';
  CheckEquals(10, FgBase.ManuallyConstructedObjectProperty.UnwriteableIntegerProperty);
  FgBase['String5'] := '123456789';
  CheckEquals('12345', FgBase.String5);
end;

procedure TestTgBase.TearDown;
begin
  FreeAndNil(FgBase);
end;

procedure TestTgBase.TestAssign;
begin
  // TODO -cMM: TestTgBase.TestAssign default body inserted
end;

procedure TestTgBase.TestCreate;
var
  Base : TgBase;
  BaseCustom: TgBaseCustom;
begin
  CheckNull(FgBase.Owner, 'When a constructor is called without a parameter, its owner should be nil.');
  CheckNotNull(FgBase.ObjectProperty, 'Object properties should be constructed automatically if the Exclude([AutoCreate]) attribute is not set.');
  CheckNull(FgBase.UnconstructedObjectProperty, 'Object properties with the Exlude([AutoCreate]) attribute should not be nil.');
  Check(FgBase=FgBase.ObjectProperty.Owner, 'The owner of an automatically constructed object property shoud be set to the object that created it.');
  CheckEquals(5, FgBase.IntegerProperty, 'Default integer values should be set for properties with a DefaultValue attribute.');
  CheckEquals('Test', FgBase.StringProperty, 'Default string values should be set for properties with a DefaultValue attribute.');
  Base := TgBase.Create;
  try
    BaseCustom := TgBaseCustom.Create(Base);
    try
      Check(BaseCustom.ObjectProperty = Base, 'Object properties should take the value of an existing owner object if one exists.');
    finally
      BaseCustom.Free;
    end;
  finally
    Base.Free;
  end;
end;

procedure TestTgBase.UndeclaredProperty;
begin
  FgBase['ThisPropertyDoesNotExist'];
end;

destructor TgBaseCustom.Destroy;
begin
  FreeAndNil(FManuallyConstructedObjectProperty);
  inherited Destroy;
end;

function TgBaseCustom.GetManuallyConstructedObjectProperty: TgBaseCustom;
begin
  if Not Assigned(FManuallyConstructedObjectProperty) then
    FManuallyConstructedObjectProperty := TgBaseCustom.Create(Self);
  Result := FManuallyConstructedObjectProperty;
end;

procedure TgBaseCustom.SetUnwriteableIntegerProperty;
begin
  FUnwriteableIntegerProperty := 10;
end;

function TgString5.GetValue: String;
begin
  Result := FValue;
end;

procedure TgString5.SetValue(const AValue: String);
begin
  FValue := Copy(AValue, 1, 5);
end;

class operator TgString5.implicit(AValue: Variant): TgString5;
begin
  Result.Value := AValue;
end;

class operator TgString5.Implicit(AValue: TgString5): Variant;
begin
  Result := AValue.Value;
end;

procedure TestTgString5.TestLength;
var
  String5: TgString5;
begin
  String5 := '123456789';
  CheckEquals('12345', String5);
end;

function TPhoneString.FormatPhone(AValue : String): String;
Var
  CurrentCharacter: Char;
Begin
  Result := '';
  for CurrentCharacter in AValue do
  Begin
    if IsNumber(CurrentCharacter) then
      Result := Result + CurrentCharacter;
  End;
  Case Length(Result) Of
    7 :
    Begin
      Insert('(   ) ', Result, 1);
      Insert('-', Result, 10);
    End;
    10 :
    Begin
      Insert('(', Result, 1);
      Insert(') ', Result, 5);
      Insert('-', Result, 10);
    End;
    Else
      Result := AValue;
  End;
End;

function TPhoneString.GetValue: String;
begin
  Result := FValue;
end;

procedure TPhoneString.SetValue(const AValue: String);
begin
  FValue := FormatPhone(AValue);
end;

class operator TPhoneString.Implicit(AValue: TPhoneString): Variant;
begin
  Result := AValue.Value;
end;

class operator TPhoneString.Implicit(AValue: Variant): TPhoneString;
begin
  Result.Value := AValue;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTgBase.Suite);
  RegisterTest(TestTgString5.Suite);
end.

